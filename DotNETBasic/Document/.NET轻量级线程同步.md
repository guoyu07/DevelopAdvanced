#异步编程：轻量级线程同步基元对象


##基元用户模式构造、基元内核模式构造、混合构造

基元线程同步构造分为：基元用户模式构造和基元内核模式构造。

* 基元用户模式构造

    应尽量使用基元用户模式构造，因为它们使用特殊的CPU指令来协调线程，这种协调发生硬件中，速度很快。但也因此Windows操作系统永远检测不到一个线程在一个用户模式构造上阻塞了，这种检测不到有利有弊：

    * 利：因为用户模式构造上阻塞的一个线程，池线程永远不认为已经阻塞，所以不会出现“线程池根据CPU使用情况误判创建更多的线程以便执行其他任务，然而新创建的线程也可能因请求的共享资源而被阻塞，恶性循环，徒增线程上下文切换的次数”的问题。

    * 弊：当你想要取得一个资源但又短时间取不到时，一个线程会一直在用户模式中运行，造成CPU资源的浪费，此时我们更希望像内核模式那样停止一个线程的运行让出CPU。

        在《异步编程：线程同步基元对象》中包含的用户模式构造有：volatile关键字、Interlocked静态类、Thread的VolatileWrite()与VolatileRead()方法。

* 基元内核模式构造

是Windows操作系统自身提供的。它们要求我们调用在操作系统内核中实现的函数，调用线程将从托管代码转换为本地用户模式代码，再转换为本地内核模式代码，然后还要朝相反的方向一路返回，会浪费大量CPU时间，同时还伴随着线程上下文切换，因此尽量不要让线程从用户模式转到内核模式。

内核模式的构造具有基元用户模式构造所不具有的一些优点：

1)         一个内核模式的构造检测到在一个资源上的竞争时，Windows会阻塞输掉的线程，使它不占着一个CPU“自旋”，无谓地浪费处理器资源。

2)         内核模式的构造可实现本地和托管线程相互之间的同步。

3)         内核模式的构造可同步在一台机器的不同进程中运行的线程。

4)         内核模式的构造可应用安全性设置，防止未经授权的帐户访问它们。

5)         一个线程可一直阻塞，直到一个集合中的所有内核模式的构造都可用，或者直到一个集合中的任何一个内核模式的构造可用。

6)         在内核模式的构造上阻塞的一个线程可以指定一个超时值；如果在指定的时间内访问不到希望的资源，线程可以解除阻塞并执行其他任务。

在《异步编程：线程同步基元对象》中包含的内核模式构造有：EventWaitHandle(以及AutoResetEvent与ManualResetEvent)、Mutex、Semaphore。（另外：ReaderWriterLock）

* 混合构造

对于在一个构造上等待的线程，如果拥有这个构造的线程一直不释放它，则会出现：

1)         如果是用户模式构造，则线程将一直占用CPU，我们称之为“活锁”。

2)         如果是内核模式构造，则线程将一直被阻塞，我们称之为“死锁”。

然后两者之间，死锁总是优于活锁，因为活锁既浪费CPU时间，又浪费内存。而死锁只浪费内存。

混合构造正是为了解决这种场景。其通过合并用户模式和内核模式实现：在没有线程竞争的时候，混合构造提供了基元用户模式构造所具有的性能优势。多个线程同时竞争一个构造的时候，混合构造则使用基元内核模式的构造来提供不“自旋”的优势。由于在大多数应用程序中，线程都很少同时竞争一个构造，所以在性能上的增强可以使你的应用程序表现得更出色。


混合结构优化的本质：两阶段等待操作


线程上下文切换需要花费几千个周期(每当线程等待内核事件WaitHandle时都会发生)。我们暂且称其为C。假如线程所等待的时间小于2C(1C用于等待自身，1C用于唤醒)，则自旋等待可以降低等待所造成的系统开销和滞后时间，从而提升算法的整体吞吐量和可伸缩性。

在多核计算机上，当预计资源不会保留很长一段时间时，如果让等待线程以用户模式旋转数十或数百个周期，然后重新尝试获取资源，则效率会更高。如果在旋转后资源变为可用的，则可以节省数千个周期。如果资源仍然不可用，则只花费了少量周期，并且仍然可以进行基于内核的等待。这一旋转-等待的组合称为“两阶段等待操作”。

在《异步编程：线程同步基元对象》中包含的有：Monitor\lock；

本节将给大家介绍.NET4.0中加入的混合结构：ManualResetEventSlim、SemaphoreSlim、CountdownEvent、Barrier、ReaderWriterLockSlim。


另外：看到园友写了篇[理解Windows内核模式与用户模式](http://www.cnblogs.com/weiym/archive/2013/01/12/2858006.html)，讲的是内核架构及用户模式调用内核模式方式。
 
 
在介绍.NET4.0新同步结构前，我们需要：

1)         认识两个协作对象：CancellationTokenSource和cancellationToken。因为它们常常被用于混合结构中。Eg：使一个线程强迫解除其构造上的等待阻塞。

2)         认识两个自旋结构：SpinWait和SpinLock

##协作式取消

###CancellationTokenSource

CancellationTokenSource相关API：

CancellationTokenSource实例Cancel()方法做了什么

分析：

1)         CancellationTokenSource.CreateLinkedTokenSource()方法

将一组CancellationToken连接起来并创建一个新的CancellationTokenSource。任何一个CancellationToken对应的旧CancellationTokenSource被取消，这个新的CancellationTokenSource对象也会被取消。

原理：创建一个新的CancellationTokenSource实例，并将该实例的Cancel()委托分别传递给这组CancellationToken实例的Register()方法，然后返回新创建的CancellationTokenSource实例。

2)         CancellationTokenSource实例Cancel()方法做了什么：

a)         将CancellationTokenSource实例的IsCancellationRequested属性设置为true。CancellationToken实例的IsCancellationRequested属性是调用CancellationTokenSource实例的IsCancellationRequested属性。

b)         调用CancellationTokenSource实例的CreateLinkedTokenSource()注册的Cancel()委托回调；

c)         调用CancellationToken实例的Register()注册的回调；

d)         处理回调异常。（参数throwOnFirstException）

    i.  若为Cancel()传递true参数，那么抛出了未处理异常的第一个回调方法会阻止其他回调方法的执行，异常会立即从Cancel()中抛出；

    ii. 若为Cancel()传递false（默认为false），那么登记的所有回调方法都会调用。所有未处理的异常都会封装到一个AggregateException对象中待回调都执行完后返回，其InnerExceptions属性包含了所有异常的详细信息。

e)    给CancellationToken对象的ManualResetEvent对象Set()信号。


###CancellationToken相关API

分析：

1)         CancellationToken是结构struct，值类型。

2)         CancellationTokenSource与CancellationToken关联是“一一对应”的

a)         无论CancellationTokenSource是通过构造函数创建还是CreateLinkedTokenSource()方法创建，与之对应的CancellationToken只有一个。

b)         每个CancellationToken都会包含一个私有字段，保存唯一与之对应的CancellationTokenSource引用。

3)         CancellationToken实例的None属性与参数不是true的CancellationToken构造函数

它们返回一个特殊的CancellationToken实例，该实例不与任何CancellationTokenSource实例关联(即不可能调用Cancel())，其CanBeCanceled实例属性为false。

4)         CancellationToken的Register()方法返回的CancellationTokenRegistration对象，可调用其Dispose()方法删除一个Register()登记的回调方法。

5)         CancellationToken实例的WaitHandle属性

会先判断若没有对应的CancellationTokenSource，则创建一个默认的CancellationTokenSource对象。然后再判断若没有内部事件等待句柄则new ManualResetEvent(false)，在CancellationTokenSource执行Cancel()时收到set()通知。;

6)         CancellationToken实例的ThrowIfCancellationRequested()方法如下：


##SpinWait结构----自旋等待

一个轻量同步类型(结构体)，提供对基于自旋的等待的支持。SpinWait只有在多核处理器下才具有使用意义。在单处理器下，自旋转会占据CPU时间，却做不了任何事。

SpinWait并没有设计为让多个任务或线程并发使用。因此，如果多个任务或者线程通过SpinWait的方法进行自旋，那么每一个任务或线程都应该使用自己的SpinWait实例。


``` C#
public struct SpinWait

{

    // 获取已对此实例调用SpinWait.SpinOnce() 的次数。

    public int Count { get; }

    // 判断对SpinWait.SpinOnce() 的下一次调用是否触发上下文切换和内核转换。

    public bool NextSpinWillYield { get; }

 

    // 重置自旋计数器。

    public void Reset();

    // 执行单一自旋。

    public void SpinOnce();

    // 在指定条件得到满足(Func<bool>委托返回true)之前自旋。

    public static void SpinUntil(Func<bool> condition);

    // 在指定条件得到满足或指定超时过期之前自旋。参数condition为在返回 true 之前重复执行的委托。

    // 返回结果:

    // 如果条件在超时时间内得到满足，则为 true；否则为 false

    public static bool SpinUntil(Func<bool> condition, int millisecondsTimeout);

    public static bool SpinUntil(Func<bool> condition, TimeSpan timeout);

}
```


``` C#
public bool NextSpinWillYield
{
    get
    {
        if (this.m_count<= 10)  // 自旋转计数
        {
            return Environment.ProcessorCount == 1;
        }
        return true;
    }
}

public void SpinOnce()
{
    if (this.NextSpinWillYield)
    {
        Int num = (this.m_count>= 10) ? (this.m_count - 10) :this.m_count;
        if ((num % 20) == 0x13)
        {
            Thread.Sleep(1);
        }
        else if ((num % 5) == 4)
        {
            Thread.Sleep(0);

        }
        else
        {
            Thread.Yield();
        }
    }
    else
    {
        Thread.SpinWait(((int) 4) < < this.m_count);
    }
    this.m_count = (this.m_count == 0x7fffffff) ?10 : (this.m_count + 1);
}


```



从代码中我们可知：

1) SpinWait自旋转是调用Thread.SpinWait()。

2) 由NextSpinWillYield属性代码可知，若SpinWait运行在单核计算机上，它总是进行上下文切换（让出处理器）。

3) SpinWait不仅仅是一个空循环。它经过了精心实现，可以针对一般情况提供正确的旋转行为以避免内核事件所需的高开销的上下文切换和内核转换；在旋转时间足够长的情况下自行启动上下文切换，SpinWait甚至还会在多核计算机上产生线程的时间片（Thread.Yield()）以防止等待线程阻塞高优先级的线程或垃圾回收器线程。

4) SpinOnce()自旋一定次数后可能导致频繁上下文切换。注意只有等待时间非常短时，SpinOnce()或SpinUntil()提供的智能行为才会获得更好的效率，否则您应该在SpinWait自行启动上下文切换之前调用自己的内核等待。

通常使用SpinWait来封装自己“两阶段等待操作”，避免内核事件所需的高开销的上下文切换和内核转换。

实现自己的“两阶段等待操作”：

``` C#
if (!spinner.NextSpinWillYield)
{spinner.SpinOnce();}

else
{自己的事件等待句柄;}
```

###SpinLock结构----自旋锁

一个轻量同步类型，提供一个相互排斥锁基元，在该基元中，尝试获取锁的线程将在重复检查的循环中等待，直至该锁变为可用为止。SpinLock是结构体，如果您希望两个副本都引用同一个锁，则必须通过引用显式传递该锁。

``` C#
 public struct SpinLock

    {

        // 初始化SpinLock结构的新实例,参数标识是否启动线程所有权跟踪以助于调试。

        public SpinLock(bool enableThreadOwnerTracking);

 

        // 获取锁当前是否已由任何线程占用。

        public bool IsHeld { get; }

        // 获取是否已为此实例启用了线程所有权跟踪。

        public bool IsThreadOwnerTrackingEnabled { get; }

        // 若IsThreadOwnerTrackingEnabled=true，则可获取锁是否已由当前线程占用。

        public bool IsHeldByCurrentThread { get; }

 

        // 采用可靠的方式获取锁，这样，即使在方法调用中发生异常的情况下，都能采用可靠的方式检查lockTaken以确定是否已获取锁。

        public void Enter(ref boollockTaken);

        public void TryEnter(ref boollockTaken);

        public void TryEnter(int millisecondsTimeout, ref bool lockTaken);

        public void TryEnter(TimeSpan timeout, ref bool lockTaken);

        // Enter(ref boollockTaken)与TryEnter(ref bool lockTaken)效果一样，TryEnter(ref boollockTaken)会跳转更多方法降低的性能。

 

        // 释放锁。参数useMemoryBarrier：指示是否应发出内存屏障，以便将退出操作立即发布到其他线程（默认为true）。

        public void Exit();

        public void Exit(bool useMemoryBarrier);

}
```

使用需注意：

1)         SpinLock支持线程跟踪模式，可以在开发阶段使用此模式来帮助跟踪在特定时间持有锁的线程。虽然线程跟踪模式对于调试很有用，但此模式可能会导致性能降低。（构造函数：可接受一个bool值以指示是否启用调试模式，跟踪线程所有权）

2)         SpinLock不可重入。在线程进入锁之后，它必须先正确地退出锁，然后才能再次进入锁。通常，任何重新进入锁的尝试都会导致死锁。

如果在调用 Exit 前没有调用 Enter，SpinLock的内部状态可能被破坏。

3)         Enter与TryEnter的选择

a)         Enter(ref boollockTaken)          在获取不到锁时会阻止等待锁可用，自旋等待，相当于等待时间传入-1（即无限期等待）。

b)         TryEnter(ref boollockTaken)              在获取不到锁时立即返回而不行进任何自旋等待，相当于等待时间传入0。

c)         TryEnter(时间参数, ref boollockTaken)           在获取不到锁时，会在指定时间内自旋等待。

d)  在指定时间内，若自旋等待足够长时间，内部会自动切换上下文进行内核等待，切换逻辑类似SpinWait结构（即，并没有使用等待事件，只是使用Thread.Sleep(0)、Thread.Sleep(1)以及Thread.Yield()），所以也可能导致频繁上下文切换。

4)         在多核计算机上，当等待时间预计较短且极少出现争用情况时，SpinLock的性能将高于其他类型的锁(长时或预期有大量阻塞，由于旋转过多，性能会下降)。但需注意的一点是，SpinLock比标准锁更耗费资源。建议您仅在通过分析确定 Monitor方法或 Interlocked 方法显著降低了程序的性能时使用SpinLock。

5)         在保持一个自旋锁时，应避免任何这些操作：

a)         阻塞，

b)         调用本身可能阻塞的任何内容，

c)         一个SpinLock结构上保持过多自旋锁，

d)         进行动态调度的调用（接口和虚方法）

e)         非托管代码的调度，或分配内存。

6)         不要将SpinLock声明为只读字段，因为如果这样做的话，会导致每次调用这个字段都返回SpinLock的一个新副本，而不是同一个SpinLock。这样所有对Enter()的调用都能成功获得锁，因此受保护的临界区不会按照预期进行串行化。

###惊奇的Monitor\lock

说到Monitor（监视器）相信大家早已铭记于心了，此结构在.NET早期版本就已经存在。但是大家可能对他是“混合构造”这一说法感到惊奇，分析下它的几个步骤：

1)         执行Monitor.Enter()/lock的线程会首先测试Monitor的锁定位。如果该位为OFF(解锁)，那么线程就会在该位上设置一下(加锁)，且不需要等待便继续。这通常只需执行1~2个机器指令。

2)         如果Monitor被锁定，线程就会进入一个旋转等待持有锁。而线程在旋转期间会反复测试锁定位。单处理器系统会立即放弃，而在多核处理器系统上则旋转一段时间才会放弃。在此之前，线程都在用户模式下运行。

3)         一旦线程放弃测试锁定位(在单处理器上立即如此)，线程使用信号量在内核进入等待状态。

4)         执行Monitor.Exit()或代码退出了lock块。如果存在等待线程，则使用ReleaseSemaphore()通知内核。

在第二步中，提到的旋转等待。正是：SpinWait。





[异步编程：轻量级线程同步基元对象](http://www.cnblogs.com/heyuquan/archive/2013/01/10/2854311.html)
[异步编程：线程同步基元对象](http://www.cnblogs.com/heyuquan/archive/2012/12/31/2840214.html)