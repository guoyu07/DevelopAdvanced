1. 单例模式

 　　单例模式指的是确保某一个类只有一个实例，并提供一个全局访问点。解决的是实体对象个数的问题，而其他的建造者模式都是解决new所带来的耦合关系问题。其实现要点有：
    * 类只有一个实例。问：如何保证呢？答：通过私有构造函数来保证类外部不能对类进行实例化
    * 提供一个全局的访问点。问：如何实现呢？答：创建一个返回该类对象的静态方法

 
2. 工厂方法模式

 　　工厂方法模式指的是定义一个创建对象的工厂接口，由其子类决定要实例化的类，将实际创建工作推迟到子类中。它强调的是”单个对象“的变化。其实现要点有：
    * 定义一个工厂接口。问：如何实现呢？答：声明一个工厂抽象类
    * 由其具体子类创建对象。问：如何去实现呢？答：创建派生于工厂抽象类，即由具体工厂去创建具体产品，既然要创建产品，自然需要产品抽象类和具体产品类了。
    在工厂方法模式中，工厂类与具体产品类具有平行的等级结构，它们之间是一一对应关系。

3. 抽象工厂模式(Abstract Factory)

    * 意图 抽象工厂模式指的是提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们具体的类。
    * 别名 Kit
    * 动机
    * 适用性
        * 一个系统要独立于它的产品的创建、组合和表示时
        * 一个系统要有多个产品系列中一个来配置时。
        * 当你要强调一系列相关的产品对象的设计以便进行联合适用时。
        * 当你提供一个产品类库，而只想显示它们的接口而不是现实时。

    * 结构
        ![抽象工厂结构]()

    * 参与者
        * AbstractFactory
            声明一个创建抽象产品对象的操作接口
        * ConcreteFactory
            实现创建产品对象的操作
        * AbstractProduct
        * ConcreteProduct

        * Client
            仅适用由AbstractFactory和AbstactProduct类声明的接口

    * 协作
        * 通常在运行时刻创建一个ConcreteFactroy类的实例。在一具体的工厂创建具有特等的产品对象。为不同的产品对象，创建不同的具体工厂。
        * AbstractFactory将产品对象的创建延迟到它的ConcreteFactory子类。

    * 效果
        优点和缺点：
        
        * 它分离了具体的类。
        * 使得易于交换产品系列
        * 它有利于产品的一致性
        * 难以支持新种类的产品

    * 实现
        1. 将工厂作为单件
        2. 创建产品 使用Factory Method来指定产品。 
        3. 定义可扩展的工厂 给创建对象的操作增加一个参数。     
    * 示例代码 

    * 已知应用
    * 相关模式

 
4. 建造者模式

    意图：建造者模式指的是将一个产品的内部表示与产品的构造过程分割开来，从而可以使一个建造过程生成具体不同的内部表示的产品对象。强调的是产品的构造过程。
    
    * 将产品的内部表示与产品的构造过程分割开来。问：如何把它们分割开呢？答：不要把产品的构造过程放在产品类中，而是由建造者类来负责构造过程，产品的内部表示放在产品类中，这样不就分割开了嘛。
    
    
5. 原型工厂模式

    原型模式指的是通过给出一个原型对象来指明所要创建的对象类型，然后用复制的方法来创建出更多的同类型对象。其实现要点有：
    * 给出一个原型对象。问：如何办到呢？答：很简单嘛，直接给出一个原型类就好了。
    * 通过复制的方法来创建同类型对象。问：又是如何实现呢？答：.NET可以直接调用MemberwiseClone方法来实现浅拷贝

