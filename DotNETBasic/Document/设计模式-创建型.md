1. 单例模式

 　　单例模式指的是确保某一个类只有一个实例，并提供一个全局访问点。解决的是实体对象个数的问题，而其他的建造者模式都是解决new所带来的耦合关系问题。其实现要点有：
    * 类只有一个实例。问：如何保证呢？答：通过私有构造函数来保证类外部不能对类进行实例化
    * 提供一个全局的访问点。问：如何实现呢？答：创建一个返回该类对象的静态方法

 
2. 工厂方法模式(Factory Method)

 　　工厂方法模式指的是定义一个创建对象的工厂接口，由其子类决定要实例化的类，将实际创建工作推迟到子类中。它强调的是”单个对象“的变化。其实现要点有：
    * 定义一个工厂接口。问：如何实现呢？答：声明一个工厂抽象类
    * 由其具体子类创建对象。问：如何去实现呢？答：创建派生于工厂抽象类，即由具体工厂去创建具体产品，既然要创建产品，自然需要产品抽象类和具体产品类了。
    在工厂方法模式中，工厂类与具体产品类具有平行的等级结构，它们之间是一一对应关系。

    * 意图
    定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。

    * 别名 虚构造器(Virtual Constructor)
    * 动机

    * 适用性
        * 当一个类不知道它必须创建的对象的类的时候
        * 当一个类希望由它的子类来指定它所创建的对象的时候
        * 当类将创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候。

    * 构造
        

3. 抽象工厂模式(Abstract Factory)

    * 意图 抽象工厂模式指的是提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们具体的类。
    * 别名 Kit
    * 动机
    * 适用性
        * 一个系统要独立于它的产品的创建、组合和表示时
        * 一个系统要有多个产品系列中一个来配置时。
        * 当你要强调一系列相关的产品对象的设计以便进行联合适用时。
        * 当你提供一个产品类库，而只想显示它们的接口而不是现实时。

    * 结构
        ![抽象工厂结构]()

    * 参与者
        * AbstractFactory
            声明一个创建抽象产品对象的操作接口
        * ConcreteFactory
            实现创建产品对象的操作
        * AbstractProduct
        * ConcreteProduct

        * Client
            仅适用由AbstractFactory和AbstactProduct类声明的接口

    * 协作
        * 通常在运行时刻创建一个ConcreteFactroy类的实例。在一具体的工厂创建具有特等的产品对象。为不同的产品对象，创建不同的具体工厂。
        * AbstractFactory将产品对象的创建延迟到它的ConcreteFactory子类。

    * 效果
        优点和缺点：
        
        * 它分离了具体的类。
        * 使得易于交换产品系列
        * 它有利于产品的一致性
        * 难以支持新种类的产品

    * 实现
        1. 将工厂作为单件
        2. 创建产品 使用Factory Method来指定产品。 
        3. 定义可扩展的工厂 给创建对象的操作增加一个参数。     
    * 示例代码 

    * 已知应用
    * 相关模式

 
4. 建造者模式(Builder)

    * 意图  将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
    
        * 将产品的内部表示与产品的构造过程分割开来。问：如何把它们分割开呢？答：不要把产品的构造过程放在产品类中，而是由建造者类来负责构造过程，产品的内部表示放在产品类中，这样不就分割开了嘛。
    * 动机
    * 适用性
        在以下情况使用Builder模式    
        * 当创建复杂对象的算法应该独立于该对象的组成部分已经它们的装配方式时。
        * 当构建过程必须允许被构造对象有不同的表示时。

    * 结构
        ![]()
    * 参与者
        * Builder  
        为创建一个Product对象各部件的接口
        * ConcreteBuilder  
        实现builder的接口以构造和装配该产品的各个部件    
         定义并明确它创建的表示    
          提供一个检索的接口
        * Director    
        构造一个使用Builder接口的对象
        * Product  
        表示被构造对象的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程。  
        包含定义组成部件的类，包括将这些部件装配成最终产品的接口

    * 协作
        * 客户创建Director对象，并且它所想要的Builder对象进行配置
        * 一旦产品部件被生成，导向器就会通知生成器。
        * 生成器处理导向器的请求，并将部件添加到改产品中
        * 客户从生成器中检索产品。

    * 效果
        1. 它使你可以改变一个产品的内部表示
        2. 它将构造代码和表示代码分开
        3. 它使你可多构造过程进行更精细的控制
     
    * 实现
        1. 装配和构造接口
        2. 为什么产品没有抽象类
        3. 在Builder中缺省的方法为空


    * 已知应用

    * 相关模式
        Abstract Factory与Builder相似
 
    
5. 原型工厂模式

    原型模式指的是通过给出一个原型对象来指明所要创建的对象类型，然后用复制的方法来创建出更多的同类型对象。其实现要点有：
    * 给出一个原型对象。问：如何办到呢？答：很简单嘛，直接给出一个原型类就好了。
    * 通过复制的方法来创建同类型对象。问：又是如何实现呢？答：.NET可以直接调用MemberwiseClone方法来实现浅拷贝

