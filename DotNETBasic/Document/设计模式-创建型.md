1. 单例模式

 　　单例模式指的是确保某一个类只有一个实例，并提供一个全局访问点。解决的是实体对象个数的问题，而其他的建造者模式都是解决new所带来的耦合关系问题。其实现要点有：
    * 类只有一个实例。问：如何保证呢？答：通过私有构造函数来保证类外部不能对类进行实例化
    * 提供一个全局的访问点。问：如何实现呢？答：创建一个返回该类对象的静态方法

    * 意图  
        保证只有一个类实例，并提供一个全局的访问点
    * 动机
    * 使用性
        * 当类只有一个实例而且客户可以从一个众所周知的访问点访问它时
        * 当这个唯一实例应该是通过之类可以可扩展的，并且客户不需要更改代码就能使用一个扩展实例时。
 
    * 结构
      ![]()

    * 参与者
        Signleton

    * 协作
    
    * 效果
        1. 唯一实例的受控访问
        2. 缩小命名空间 Signton模式是对全局变量的一种改进。它避免了那些存储唯一实例的全局变量污染命名空间
        3. 允许对操作和表示的精化 
        4. 允许可变数目的实例
        5. 比类操作更灵活
        6. 

    * 实现
        1. 保证一个唯一的实例
        2. 创建Signleton类的子类   更灵活使用单件注册表（IOC）       
        
 
2. 工厂方法模式(Factory Method)

 　　工厂方法模式指的是定义一个创建对象的工厂接口，由其子类决定要实例化的类，将实际创建工作推迟到子类中。它强调的是”单个对象“的变化。其实现要点有：
    * 定义一个工厂接口。问：如何实现呢？答：声明一个工厂抽象类
    * 由其具体子类创建对象。问：如何去实现呢？答：创建派生于工厂抽象类，即由具体工厂去创建具体产品，既然要创建产品，自然需要产品抽象类和具体产品类了。
    在工厂方法模式中，工厂类与具体产品类具有平行的等级结构，它们之间是一一对应关系。

    * 意图
    定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。  
    *感觉委托有时候更方便*

    * 别名 虚构造器(Virtual Constructor)
    * 动机

    * 适用性
        * 当一个类不知道它必须创建的对象的类的时候
        * 当一个类希望由它的子类来指定它所创建的对象的时候
        * 当类将创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候。

    * 构造
        ![工厂方法结构]()

    * 参与者
        * Product  
        定义工厂方法所创建的对象的接口  
        * ConcreteProduct
        实现Product方法
        * Creator
        声明工厂方法，该方法返回一个Product类型的对象。Creator也定义一个工厂方法的缺省实现。它返回一个缺省的ConcreteProduct对象
        * ConcreteCreator
        重定义工厂方法以返回一个ConcreteProduct实例

    * 协作
    * 效果  
        可以按需要创建子类
        * 为子类提供挂钩
        * 连接平行的类层次
    * 实现
        1. 主要两种不同的情况,1)Creator类使抽象类并且不提供它声明的工厂方法实现。2)Creator是具体类并且为工厂党提供一个缺省的提示

        2. 参数化工厂方法 该模式的另一种情况使得工厂方法可以创建多种产品。子类可以提供不同的版本，最后调用父类

        3. 特定语言的变化和问题 
        4. 使用模板以避免子类    
        5. 命名约定

    * 已知应用
        
    * 相关模式  
        Abstract Factory 经常用工厂方法来实现。
  

3. 抽象工厂模式(Abstract Factory)

    * 意图 抽象工厂模式指的是提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们具体的类。
    * 别名 Kit
    * 动机
    * 适用性
        * 一个系统要独立于它的产品的创建、组合和表示时
        * 一个系统要有多个产品系列中一个来配置时。
        * 当你要强调一系列相关的产品对象的设计以便进行联合适用时。
        * 当你提供一个产品类库，而只想显示它们的接口而不是现实时。

    * 结构
        ![抽象工厂结构]()

    * 参与者
        * AbstractFactory
            声明一个创建抽象产品对象的操作接口
        * ConcreteFactory
            实现创建产品对象的操作
        * AbstractProduct
        * ConcreteProduct

        * Client
            仅适用由AbstractFactory和AbstactProduct类声明的接口

    * 协作
        * 通常在运行时刻创建一个ConcreteFactroy类的实例。在一具体的工厂创建具有特等的产品对象。为不同的产品对象，创建不同的具体工厂。
        * AbstractFactory将产品对象的创建延迟到它的ConcreteFactory子类。

    * 效果
        优点和缺点：
        
        * 它分离了具体的类。
        * 使得易于交换产品系列
        * 它有利于产品的一致性
        * 难以支持新种类的产品

    * 实现
        1. 将工厂作为单件
        2. 创建产品 使用Factory Method来指定产品。 
        3. 定义可扩展的工厂 给创建对象的操作增加一个参数。     
    * 示例代码 

    * 已知应用
    * 相关模式

 
4. 建造者模式(Builder)

    * 意图  将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
    
        * 将产品的内部表示与产品的构造过程分割开来。问：如何把它们分割开呢？答：不要把产品的构造过程放在产品类中，而是由建造者类来负责构造过程，产品的内部表示放在产品类中，这样不就分割开了嘛。
    * 动机
    * 适用性
        在以下情况使用Builder模式    
        * 当创建复杂对象的算法应该独立于该对象的组成部分已经它们的装配方式时。
        * 当构建过程必须允许被构造对象有不同的表示时。

    * 结构
        ![]()
    * 参与者
        * Builder  
        为创建一个Product对象各部件的接口
        * ConcreteBuilder  
        实现builder的接口以构造和装配该产品的各个部件    
         定义并明确它创建的表示    
          提供一个检索的接口
        * Director    
        构造一个使用Builder接口的对象
        * Product  
        表示被构造对象的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程。  
        包含定义组成部件的类，包括将这些部件装配成最终产品的接口

    * 协作
        * 客户创建Director对象，并且它所想要的Builder对象进行配置
        * 一旦产品部件被生成，导向器就会通知生成器。
        * 生成器处理导向器的请求，并将部件添加到改产品中
        * 客户从生成器中检索产品。

    * 效果
        1. 它使你可以改变一个产品的内部表示
        2. 它将构造代码和表示代码分开
        3. 它使你可多构造过程进行更精细的控制
     
    * 实现
        1. 装配和构造接口
        2. 为什么产品没有抽象类
        3. 在Builder中缺省的方法为空


    * 已知应用

    * 相关模式
        Abstract Factory与Builder相似
 
    
5. 原型工厂模式

    原型模式指的是通过给出一个原型对象来指明所要创建的对象类型，然后用复制的方法来创建出更多的同类型对象。其实现要点有：
    * 给出一个原型对象。问：如何办到呢？答：很简单嘛，直接给出一个原型类就好了。
    * 通过复制的方法来创建同类型对象。问：又是如何实现呢？答：.NET可以直接调用MemberwiseClone方法来实现浅拷贝

    * 意图    
    用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
    * 动机  
    图形编辑器框架  使用Clone方法
    
    * 适用性  
    当一个系统应该独立于它的产品创建、构成和表示时，要使用Prototype模型，以及
        * 当要实例化的类是在运行时刻指定是，例如，通过动态装载
        * 为了避免创建一个与产品类层次平行的工厂类层次时
        * 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例该类更方便一些。

    * 结构
    * 参与者
        * Prototype  
        声明一个支持克隆自身的操作
        * ConcretePrototype  
         实现一个克隆自身的操作
        * Client  
        让一个原型克隆自身从而创建一个新的对象

    * 协作
    * 效果
        1. 运行时刻增加和删除产品
        2. 改变值已指定新对象  
        像Onedirve新API一样，item对象
        3. 改变结构已指定新的对象  
        减少子类的构造
        4. 用动态配置应用
        
    * 实现
        1. 使用一个原型管理器
        2. 实现一个克隆操作 Prototype模式最困难的部分在于正确实现Coloe操作。当对象结构包含循环引用时，这尤为棘手。

        3. 初始化克隆对象
        
    * 已知应用
    * 相关模式


6. 创建模式的讨论

    
        
        