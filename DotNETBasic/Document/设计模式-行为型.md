行为模式涉及到算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述它们之间的通信。这些模式刻画了再运行
是难以跟踪的复杂的控制流。它们将你的注意力从控制流转移到对象间的联系方式上来。

行为模式使用继承机制在类间分派行为。Tempalte Method ,Interpreter

行为对象模式使用对象复合而不是继承。一些行为对象模式描述了一组对等的对象怎样相互协作已完成其中任一个对象都无法单独
完成的任务。Mediator,Chain of responsibility，Observer

其他的行为对象模式定义并保持对象间的依赖关系。


1. 模板方法模式

    在现实生活中，有论文模板，简历模板等。在现实生活中，模板的概念是给定一定的格式，然后其他所有使用模板的人可以根据自己的需求去实现它。同样，模板方法也是这样的。
    模板方法模式是在一个抽象类中定义一个操作中的算法骨架，而将一些具体步骤实现延迟到子类中去实现。模板方法使得子类可以不改变算法结构的前提下，重新定义算法的特定步骤，从而达到复用代码的效果。具体的结构图如下所示。
    
2. 命令模式（Command）

    命令模式属于对象的行为模式，命令模式把一个请求或操作封装到一个对象中，通过对命令的抽象化来使得发出命令的责任和执行命令的责任分隔开。命令模式的实现可以提供命令的撤销和恢复功能。

    * 意图 
        将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
    * 别名
        动作(Action),事务（Transaction）
    * 动机
    * 适用性
        * Command模式是回回调机制的一个面向对象的替代品。
        * 在不同时刻指定、排列和执行请求
        * 支持取消操作
        * 支持修改日志
        * 用构建在原语操作上高层操作构建一个系统。 transaction

    * 结构
        ![](https://github.com/wei772/DotNETBasic/blob/master/DotNETBasic/Image/%E5%91%BD%E4%BB%A4%E7%BB%93%E6%9E%84.PNG)

    * 参与者
        * Command  
        声明执行操作的接口
        * ConcreteCommand
        将一个接受者对象绑定与一个动作
        调用接受者相应的操作，已实现Execute

        * Client  
        创建一个具体命令对象并设定它的接受者

        * Invoker  
        要求该命令执行这个请求

        * Receiver  
        知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接受者。

    * 协作

    * 效果
        1. Command模式将调用操作的对象与知道如何实现该操作的对象解耦。
        2. Command是头等的对象。它们可像其他的对象一样被操作和扩展。
        3. 你可将命令组装成一个复合命令
        4. 增加新的Command很容易，因为无需改变已有的类。

    * 实现
        1. 一个命令对象应达到何种智能程度
        2. 支持取消和重做
        3. 避免取消操作过程中的错误积累
        4. 使用C++模板

          

3. 迭代器模式

    迭代器模式是针对集合对象而生的，对于集合对象而言，必然涉及到集合元素的添加删除操作，也肯定支持遍历集合元素的操作，此时如果把遍历操作也放在集合对象的话，集合对象就承担太多的责任了，此时可以进行责任分离，把集合的遍历放在另一个对象中，这个对象就是迭代器对象。
    
    迭代器模式提供了一种方法来顺序访问一个集合对象中各个元素，而又无需暴露该对象的内部表示，这样既可以做到不暴露集合的内部结构，又可以让外部代码透明地访问集合内部元素。具体的结构图如下所示。

    * 意图  
        提供一种方法顺序刚问一个聚合对象中各个元素，而不暴露该对象的内部表示。
    * 别名  
        游标(Cursor)
    * 动机
    * 适用性
        * 访问一个聚合对象的内容而不需要暴露它的内部表示
        * 支持对聚合对象的多种遍历
        * 为遍历不同的聚合结果提供一个统一的接口

    * 结构
        ![](https://github.com/wei772/DotNETBasic/blob/master/DotNETBasic/Image/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%BB%93%E6%9E%84.PNG)
    * 参与者
        * Iterator（迭代器）  
            迭代器定义访问和遍历元素的接口
        * ConcreateIterator   
            具体迭代器实现迭代器接口
            对该聚合遍历时跟踪当前位置
        * Aggregate（聚合）  
            聚合定义创建相应迭代器对象的接口
        * ConcreteAggregate
            具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适应的实例。

    * 效果
        1. 它支持以不同的方式遍历一个聚合
        2. 迭代器简化了聚合的接口
        3. 在同一个聚合上可以有多个遍历
    * 实现
        1. 谁控制该迭代
        2. 谁定义遍历算法
        3. 迭代器健壮程度如何（这个不错）
        4. 附加的迭代器操作
        5. 在C++中使用多态的迭代器
        6. 迭代器可有特权访问
        7. 用于复用对象的迭代器
        8. 空迭代器

    * 已知应用
        

4. 观察者模式

    在现实生活中，处处可见观察者模式，例如，微信中的订阅号，订阅博客和QQ微博中关注好友，这些都属于观察者模式的应用。
    
    观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己的行为。
    
5. 中介者模式(Mediator)

    在现实生活中，有很多中介者模式的身影，例如QQ游戏平台，聊天室、QQ群和短信平台，这些都是中介者模式在现实生活中的应用。                   
    中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。具体的结构图如下所示：
    * 意图   
        用一个中介对象来封装一系列对象的江湖。中介者使对象不需要显示的相互引用，从而耦合松散，而且可以独立地改变它们之间的交互。
    * 动机  
        面向对象设计鼓励奖行为分布到各个对象中。这种分布可能会导致对象间有许多连接。在最坏的情况下，每一个对象都知道其他所有对象。    
        虽然将一个系统分割成许多对象通常可以增强可复用性，但是对象间相互连接又会降低其复用性。大量的相互连接使得一个对象似乎不太可能在没有其他对象的支持下，工作-系统表现为一个不可分割的整体。

        图形界面。可以通过将集体行为封装在一个单独的*中介者*（Mediator）对象来避免这个问题。

    * 适用性
        * 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。
        * 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。
        * 想定制一个分布在多个类中的行为，而又不想生成太多的子类。

    * 结构
        ![](https://github.com/wei772/DotNETBasic/blob/master/DotNETBasic/Image/%E4%B8%AD%E4%BB%8B%E8%80%85%E7%BB%93%E6%9E%84.PNG)

    * 参与者
        * Mediator  
            中介者定义一个接口用于与各同事(Colleague)对象通信。
        * ConcreteMediator
            具体中介者通过协调各同事实现协作行为。  
            了解并维护它的各个同事。
        * Colleague class  
            每一个同事类都知道它的中介者对象。  
            每一个同事对象在需与其他的同事通信的时候，与它的中介者通信。  
    * 协作
        * 同事向一个中介者对象发送和接收请求。中介者在各同事间适当的转发请求以实现协作行为。

    * 效果
        1. 减少子类的生成
        2. 它将各Colleague解耦
        3. 它简化了对象协议
        4. 它对对象如何协作进行了抽象
        5. 它是控制集中化

    * 实现
        1. 忽略抽象的Mediator类
        2. Colleague-Mediator通信
        
    * 相关模式

6. 状态模式

    每个对象都有其对应的状态，而每个状态又对应一些相应的行为，如果某个对象有多个状态时，那么就会对应很多的行为。那么对这些状态的判断和根据状态完成的行为，就会导致多重条件语句，并且如果添加一种新的状态时，需要更改之前现有的代码。这样的设计显然违背了开闭原则，状态模式正是用来解决这样的问题的。
    状态模式——允许一个对象在其内部状态改变时自动改变其行为，对象看起来就像是改变了它的类。具体的结构图如下所示：
    
7. 策略模式

    在现实生活中，中国的所得税，分为企业所得税、外商投资企业或外商企业所得税和个人所得税，针对于这3种所得税，每种所计算的方式不同，个人所得税有个人所得税的计算方式，而企业所得税有其对应计算方式。如果不采用策略模式来实现这样一个需求的话，我们会定义一个所得税类，该类有一个属性来标识所得税的类型，并且有一个计算税收的CalculateTax()方法，在该方法体内需要对税收类型进行判断，通过if-else语句来针对不同的税收类型来计算其所得税。这样的实现确实可以解决这个场景，但是这样的设计不利于扩展，如果系统后期需要增加一种所得税时，此时不得不回去修改CalculateTax方法来多添加一个判断语句，这样明白违背了“开放——封闭”原则。此时，我们可以考虑使用策略模式来解决这个问题，既然税收方法是这个场景中的变化部分，此时自然可以想到对税收方法进行抽象，这也是策略模式实现的精髓所在。
    
    策略模式是对算法的包装，是把使用算法的责任和算法本身分割开，委派给不同的对象负责。策略模式通常把一系列的算法包装到一系列的策略类里面。用一句话慨括策略模式就是——“将每个算法封装到不同的策略类中，使得它们可以互换”。
    
8. 责任链模式（Chain of responsibility）
    
    在现实生活中，有很多请求并不是一个人说了就算的，例如面试时的工资，低于1万的薪水可能技术经理就可以决定了，但是1万~1万5的薪水可能技术经理就没这个权利批准，可能需要请求技术总监的批准。              
    责任链模式——某个请求需要多个对象进行处理，从而避免请求的发送者和接收之间的耦合关系。将这些对象连成一条链子，并沿着这条链子传递该请求，直到有对象处理它为止

    * 意图  
        使多个对象都有机会处理请求，从而避免请求和发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条
        链传递该请求，直到有一个对象处理为止。

    * 动机

    * 结构
        ![](https://github.com/wei772/DotNETBasic/blob/master/DotNETBasic/Image/%E8%81%8C%E8%B4%A3%E9%93%BE%E7%BB%93%E6%9E%84.PNG)
    * 参与者
        * Handler  
            定义一个处理请求的接口
            实现后继续
        * ConcreteHander  
            处理它所负责的请求  
            可访问它的后继者  
            如果可处理该请求，就处理之；否则将该请求转发给它的后继者
        * Client
            向链上的具体处理者提交请求
    * 协作  
        当客户提交一个请求时，请求沿链传递直至有一个ConcreteHandler对象负责处理它。

    * 效果
        1. 降低耦合度
        2. 增强了给对象指派职责的灵活性
        3. 不保证被接受
    * 实现
        1. 实现后继者链
        2. 连接后继者
        3. 表示请求
    * 已知应用
        许多类库使用职责链模式处理用户事件。

    * 相关模式

    
9. 访问者模式

    访问者模式是封装一些施加于某种数据结构之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保存不变。访问者模式适用于数据结构相对稳定的系统， 它把数据结构和作用于数据结构之上的操作之间的耦合度降低，使得操作集合可以相对自由地改变。
    
10. 备忘录模式

    生活中的手机通讯录备忘录，操作系统备份点，数据库备份等都是备忘录模式的应用。备忘录模式是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以把该对象恢复到原先的状态。具体的结构图如下所示：
    
11. 解释器模式

    解释器模式是一个比较少用的模式，所以我自己也没有对该模式进行深入研究，在生活中，英汉词典的作用就是实现英文和中文互译，这就是解释器模式的应用。
    解释器模式是给定一种语言，定义它文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释器语言中的句子。具体的结构图如下所示：

    * 意图
        给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该比表示来解释语言中的句子。
    
