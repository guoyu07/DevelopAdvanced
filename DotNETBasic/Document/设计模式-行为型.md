行为模式涉及到算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述它们之间的通信。这些模式刻画了再运行
是难以跟踪的复杂的控制流。它们将你的注意力从控制流转移到对象间的联系方式上来。

行为模式使用继承机制在类间分派行为。Tempalte Method ,Interpreter

行为对象模式使用对象复合而不是继承。一些行为对象模式描述了一组对等的对象怎样相互协作已完成其中任一个对象都无法单独
完成的任务。Mediator,Chain of responsibility，Observer

其他的行为对象模式定义并保持对象间的依赖关系。


1. 模板方法模式

    在现实生活中，有论文模板，简历模板等。在现实生活中，模板的概念是给定一定的格式，然后其他所有使用模板的人可以根据自己的需求去实现它。同样，模板方法也是这样的。
    模板方法模式是在一个抽象类中定义一个操作中的算法骨架，而将一些具体步骤实现延迟到子类中去实现。模板方法使得子类可以不改变算法结构的前提下，重新定义算法的特定步骤，从而达到复用代码的效果。具体的结构图如下所示。
    *登录可以使用这种方式去做吧*
    * 意图
        定义一个操作中的算法骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构既可重定义该算法的某些特定步骤。

    * 动机
        通过使用抽象操作定义一个算法中的一些步骤，模板方法确定了它们的先后顺序，单它允许Application和Document子类改变这些具体步骤以满足它们各自的需求。

    * 适用性
        * 一次性实现一个算法的不变部分，并将可变的行为给子类实现。
        * 将子类中公共行为被提取出来并集中到一个公共父类以避免代码重复。
        * 控制子类扩展。

    * 结构

    * 参与者
        * AbtractClass
            定义抽象的原语操作，具体子类将重定义它们以实现一个算法的各步骤。  
            实现一个模板方法，定义一个算法骨架。

        * ConcreteClass  
            实现原语操作以完成算法中与特等子类相关的步骤。

    * 协作
    * 效果
        模板方法是一种代码复用的基本技术。它们在类库中尤为重要，它们提取了类库中的公共行为。

        模板方法导致一种方向的控制结构，这种结构优势被称为“好莱坞法则，即“别找我们，我们来找你”。这指的是一个父类调用子类的一个子类的操作，而不是相反。

        模板方法调用下列类型的操作:
            * 具体操作
            * 具体的AbstractClass的操作
            * 原语操作(抽象操作)
            * Factory Method
            * 钩子操作

    * 实现
        1. 使用C++访问控制
        2. 尽量减少原语操作
        3. 命名约定

    * 相关模式
    
        
            

2. 命令模式（Command）

    命令模式属于对象的行为模式，命令模式把一个请求或操作封装到一个对象中，通过对命令的抽象化来使得发出命令的责任和执行命令的责任分隔开。命令模式的实现可以提供命令的撤销和恢复功能。

    * 意图 
        将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
    * 别名
        动作(Action),事务（Transaction）
    * 动机
    * 适用性
        * Command模式是回回调机制的一个面向对象的替代品。
        * 在不同时刻指定、排列和执行请求
        * 支持取消操作
        * 支持修改日志
        * 用构建在原语操作上高层操作构建一个系统。 transaction

    * 结构
        ![](https://github.com/wei772/DotNETBasic/blob/master/DotNETBasic/Image/%E5%91%BD%E4%BB%A4%E7%BB%93%E6%9E%84.PNG)

    * 参与者
        * Command  
        声明执行操作的接口
        * ConcreteCommand
        将一个接受者对象绑定与一个动作
        调用接受者相应的操作，已实现Execute

        * Client  
        创建一个具体命令对象并设定它的接受者

        * Invoker  
        要求该命令执行这个请求

        * Receiver  
        知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接受者。

    * 协作

    * 效果
        1. Command模式将调用操作的对象与知道如何实现该操作的对象解耦。
        2. Command是头等的对象。它们可像其他的对象一样被操作和扩展。
        3. 你可将命令组装成一个复合命令
        4. 增加新的Command很容易，因为无需改变已有的类。

    * 实现
        1. 一个命令对象应达到何种智能程度
        2. 支持取消和重做
        3. 避免取消操作过程中的错误积累
        4. 使用C++模板

          

3. 迭代器模式

    迭代器模式是针对集合对象而生的，对于集合对象而言，必然涉及到集合元素的添加删除操作，也肯定支持遍历集合元素的操作，此时如果把遍历操作也放在集合对象的话，集合对象就承担太多的责任了，此时可以进行责任分离，把集合的遍历放在另一个对象中，这个对象就是迭代器对象。
    
    迭代器模式提供了一种方法来顺序访问一个集合对象中各个元素，而又无需暴露该对象的内部表示，这样既可以做到不暴露集合的内部结构，又可以让外部代码透明地访问集合内部元素。具体的结构图如下所示。

    * 意图
        提供一种方法顺序刚问一个聚合对象中各个元素，而不暴露该对象的内部表示。
    * 别名
        游标(Cursor)
    * 动机
    * 适用性
        * 访问一个聚合对象的内容而不需要暴露它的内部表示
        * 支持对聚合对象的多种遍历
        * 为遍历不同的聚合结果提供一个统一的接口

    * 结构
        ![](https://github.com/wei772/DotNETBasic/blob/master/DotNETBasic/Image/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%BB%93%E6%9E%84.PNG)
    * 参与者
        * Iterator（迭代器）  
            迭代器定义访问和遍历元素的接口
        * ConcreateIterator   
            具体迭代器实现迭代器接口
            对该聚合遍历时跟踪当前位置
        * Aggregate（聚合）  
            聚合定义创建相应迭代器对象的接口
        * ConcreteAggregate
            具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适应的实例。

    * 效果
        1. 它支持以不同的方式遍历一个聚合
        2. 迭代器简化了聚合的接口
        3. 在同一个聚合上可以有多个遍历
    * 实现
        1. 谁控制该迭代
        2. 谁定义遍历算法
        3. 迭代器健壮程度如何（这个不错）
        4. 附加的迭代器操作
        5. 在C++中使用多态的迭代器
        6. 迭代器可有特权访问
        7. 用于复用对象的迭代器
        8. 空迭代器

    * 已知应用
        

4. 观察者模式(Observer)

    在现实生活中，处处可见观察者模式，例如，微信中的订阅号，订阅博客和QQ微博中关注好友，这些都属于观察者模式的应用。
    
    观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己的行为。
    
    * 意图  
       定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变是，所有依赖与它的对象都得到通知并自动更新。

    * 别名
        依赖(Dependents)，发布-订阅(Publish-Subscribe)

    * 动机  
         将一个系统分割成系类相互协作的类有一个常用的副作用：需要维护相关对象间的一致性。我们不希望为了维护
        一致性而使各类解耦合，因为这样降低了它们的重用性。

    * 适用性       
        * 当一个抽象模型有两个方面，其中一个方面依赖与另一个方面。将这两者封装在独立地对象中以使它们可以各自独立的改变和复用。
        * 当对一个对象的改变需要同时改变其它对象，而不知道集体有多少对象有待改变。
        * 当一个对象必须通知其它对象，而它又不能假定其它对象时谁。换言之，你不希望这些对象时紧密耦合的。

    * 结构
        ![]()

    * 参与者
        * Subject   
        目标知道它的观察者。可以有任意多个观察者观察同一目标。  
        提供注册和删除观察者对象的接口。  
        * Observer  
        为那些在目标发生改变时需要获得通知的对象顶一个更新接口。  
        * ConcreteSuject
        将有关状态存入各ConcreteObserver对象。  
           将它的状态发生改变时，想它的各个观察者发出通知。

        * ConcreteObsever  
         维护一个指向ConcreteSubject对象的引用。  
        存储有关状态，这些状态与目标的状态保持一致。  
        实现Observer的更新接口已使自身状态与目标状态保持一致。

    * 协作
        
    * 效果
        1. 目标和观察者间的抽象耦合
        2. 支持广播通信
        3. 意外的更新  
            *不提供具体细节说明目标中改变了什么*，这就使得上述问题更加严重。

    * 实现
        1. 创建目标到观察者之间的映射  关联机制(例如hash表)

        2. 观察多个目标

        3. 谁触发更新  a.目标 b.客户

        4. 对已删除目标的悬挂引用

        5. 在发出通知前后确保目标的状态自身是一致的

        6. 避免特等与观察者更新协议- 推/拉模型 (push  pull) 
            一个极端情况是，目标想观察者发送改变的详细细节，而不管他们需要与否。我们称之为推模型。另一个
            极端是拉模型;目标出最小通知外什么不送出，而在次之后观察者显式的向目标询问细节。

        7. 显式地指定感兴趣的改变    目标对象方面(aspects)的概念
    
        8. 封装复杂的更新语义
            当目标和观察者的依赖关系特别复杂时，可能需要一个维护这个关系的对象，我们称这样的对象为*更改管理器*(ChangeManager)。
            它的目的是尽可能减少观察者反映其目标的状态所需的工作量。  
            ChangeManager有三个职责:
                1. 它将一个目标映射到它的观察者并提供一个接口来维护这个映射。
                2. 它定义一个特等的更新策略。        
                3. 根据一个目标的请求，它更新所有依赖与这个目标的观察者。

            
        9. 结合目标类和观察类
            用不支持多重继承的语言，通常不单独定义Subject和Observer类，而是将它们的接口结合到一个类中。

    * 相关模式

5. 中介者模式(Mediator)

    在现实生活中，有很多中介者模式的身影，例如QQ游戏平台，聊天室、QQ群和短信平台，这些都是中介者模式在现实生活中的应用。                   
    中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。具体的结构图如下所示：
    * 意图
        用一个中介对象来封装一系列对象的江湖。中介者使对象不需要显示的相互引用，从而耦合松散，而且可以独立地改变它们之间的交互。
    * 动机
        面向对象设计鼓励奖行为分布到各个对象中。这种分布可能会导致对象间有许多连接。在最坏的情况下，每一个对象都知道其他所有对象。  
        虽然将一个系统分割成许多对象通常可以增强可复用性，但是对象间相互连接又会降低其复用性。大量的相互连接使得一个对象似乎不太可能在没有其他对象的支持下，工作-系统表现为一个不可分割的整体。

        图形界面。可以通过将集体行为封装在一个单独的*中介者*（Mediator）对象来避免这个问题。

    * 适用性
        * 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。
        * 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。
        * 想定制一个分布在多个类中的行为，而又不想生成太多的子类。

    * 结构
        ![](https://github.com/wei772/DotNETBasic/blob/master/DotNETBasic/Image/%E4%B8%AD%E4%BB%8B%E8%80%85%E7%BB%93%E6%9E%84.PNG)

    * 参与者
        * Mediator  
            中介者定义一个接口用于与各同事(Colleague)对象通信。
        * ConcreteMediator
            具体中介者通过协调各同事实现协作行为。  
            了解并维护它的各个同事。
        * Colleague class  
            每一个同事类都知道它的中介者对象。  
            每一个同事对象在需与其他的同事通信的时候，与它的中介者通信。  
    * 协作
        * 同事向一个中介者对象发送和接收请求。中介者在各同事间适当的转发请求以实现协作行为。

    * 效果
        1. 减少子类的生成
        2. 它将各Colleague解耦
        3. 它简化了对象协议
        4. 它对对象如何协作进行了抽象
        5. 它是控制集中化

    * 实现
        1. 忽略抽象的Mediator类
        2. Colleague-Mediator通信
        
    * 相关模式

6. 状态模式（State）

    每个对象都有其对应的状态，而每个状态又对应一些相应的行为，如果某个对象有多个状态时，那么就会对应很多的行为。那么对这些状态的判断和根据状态完成的行为，就会导致多重条件语句，并且如果添加一种新的状态时，需要更改之前现有的代码。这样的设计显然违背了开闭原则，状态模式正是用来解决这样的问题的。
    状态模式——允许一个对象在其内部状态改变时自动改变其行为，对象看起来就像是改变了它的类。具体的结构图如下所示：
    
    * 意图  
    允许一个对象在器内部状态改变时改变它的行为。对象看起来修改了它的类。

    * 别名   状态对象(Objects for States)

    * 动机  TcpConnetion

    * 适用性

        * 一个对象的行为取决于它的状态，并且它必须运行时刻根据状态改变它的行为。
        * 一个操作中含有庞大的多分支的条件语句，且这些分支依赖与该对象的状态。这个状态通常用一个或对个枚举值常量表示。

    * 结构
        ![]()

    * 参与者
        * Context  
            定义客户感兴趣的接口  
            维护一个ConcreteState子类的实例，这个实例定义当前状态。
        * State
            定义一个接口以封装与Context的一个特等状态相关的行为。

        * ConcreteState subClasses  
            每一子类实现一个与Context的一个状态相关的行为。

    * 协作
        
    * 效果

        1. 它将于特等状态相关的行为局部化，并且将不同的状态的行为分割开来。
            另外一个方法是使用数据值定义内部状态并且让Context操作来显式地检查这些数据。许多if或case语句。

        2. 它使得状态转换显式化

        3. State对象可以被共享

    * 实现

        1. 谁定义状态转换
        2. 基于表的另一种方法
        3. 创建和销毁State对象
        4. 使用动态继承

    * 相关模式



7. 策略模式

    在现实生活中，中国的所得税，分为企业所得税、外商投资企业或外商企业所得税和个人所得税，针对于这3种所得税，每种所计算的方式不同，个人所得税有个人所得税的计算方式，而企业所得税有其对应计算方式。如果不采用策略模式来实现这样一个需求的话，我们会定义一个所得税类，该类有一个属性来标识所得税的类型，并且有一个计算税收的CalculateTax()方法，在该方法体内需要对税收类型进行判断，通过if-else语句来针对不同的税收类型来计算其所得税。这样的实现确实可以解决这个场景，但是这样的设计不利于扩展，如果系统后期需要增加一种所得税时，此时不得不回去修改CalculateTax方法来多添加一个判断语句，这样明白违背了“开放——封闭”原则。此时，我们可以考虑使用策略模式来解决这个问题，既然税收方法是这个场景中的变化部分，此时自然可以想到对税收方法进行抽象，这也是策略模式实现的精髓所在。
    
    策略模式是对算法的包装，是把使用算法的责任和算法本身分割开，委派给不同的对象负责。策略模式通常把一系列的算法包装到一系列的策略类里面。用一句话慨括策略模式就是——“将每个算法封装到不同的策略类中，使得它们可以互换”。
    
    * 意图
        定义一系列算法，把它们一个个封装起来，并且是它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

    * 别名  政策（Policy）
    
    * 动机

    * 适用性
        * 许多相关的类仅仅是行为有异，"策略"提供了一种行为中的一个行为来配置一个类的方法。
        * 需要使用一个算法的不同变体。
        * 算法使用乐乎不应该知道的数据。
        * 一个类定义了多种行为，并且这些行为在这个类中的操作以对个条件语句的形式出现。

    * 结构
        ![]()

    * 参与者
        * Strategy  
            定义所有支持的算法的公共接口。
        * ConcreteStrategy  
              以Strategy接口实现某具体算法
        * Context  
              用一个ConcreteStrategy对象来配置  
            维护一个队Strategy对象的引用。  
            可定义一个接口来让Stategy访问它的数据

    * 协作
        * Strategy和Context相互作用已实现选定的算法。
        * Context将它的客户的请求转发给它的Strategy。客户通常创建并传递一个ConcreteStrategy对象给该Context;这样，客户仅与Context交互。

    * 效果
        1. 相关算法系列
        2. 一个代替继承的方法
        3. 清除一些条件语句
        4. 实现的选择

        5. 客户必须了解不同的Strategy
        6. Strategy和Context之间的通信开销
        7. 增加的对象的数目

    * 实现
        1. 定义Strategy和Context接口
        2. 将Strategy作为模板参数
        3. 使Strategy对象称为可选的

        
         
   
8. 责任链模式（Chain of responsibility）
    
    在现实生活中，有很多请求并不是一个人说了就算的，例如面试时的工资，低于1万的薪水可能技术经理就可以决定了，但是1万~1万5的薪水可能技术经理就没这个权利批准，可能需要请求技术总监的批准。              
    责任链模式——某个请求需要多个对象进行处理，从而避免请求的发送者和接收之间的耦合关系。将这些对象连成一条链子，并沿着这条链子传递该请求，直到有对象处理它为止

    * 意图
        使多个对象都有机会处理请求，从而避免请求和发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条
        链传递该请求，直到有一个对象处理为止。

    * 动机

    * 结构
        ![](https://github.com/wei772/DotNETBasic/blob/master/DotNETBasic/Image/%E8%81%8C%E8%B4%A3%E9%93%BE%E7%BB%93%E6%9E%84.PNG)
    * 参与者
        * Handler  
            定义一个处理请求的接口
            实现后继续
        * ConcreteHander  
            处理它所负责的请求  
            可访问它的后继者  
            如果可处理该请求，就处理之；否则将该请求转发给它的后继者
        * Client
            向链上的具体处理者提交请求
    * 协作
        当客户提交一个请求时，请求沿链传递直至有一个ConcreteHandler对象负责处理它。

    * 效果
        1. 降低耦合度
        2. 增强了给对象指派职责的灵活性
        3. 不保证被接受
    * 实现
        1. 实现后继者链
        2. 连接后继者
        3. 表示请求
    * 已知应用
        许多类库使用职责链模式处理用户事件。

    * 相关模式

    
9. 访问者模式

    访问者模式是封装一些施加于某种数据结构之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保存不变。访问者模式适用于数据结构相对稳定的系统， 它把数据结构和作用于数据结构之上的操作之间的耦合度降低，使得操作集合可以相对自由地改变。
    
    * 意图  
        表示一个作用于某对象结构中的各元素的操作。它使你可以再不改变各元素的类的前提下定义作用于这些元素的新操作。

    * 动机

    * 适用性
        * 一个对象结构包含很多类对象，它们不同的接口，而你想对这些对象实施一些依赖与某具体类的操作
        * 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这个操作"污染"这些对象的类。
        * 定义对象结构的类很少改变，但经常需要再次结构上定义新的操作。

    * 结构
        ![]()

    * 参与者
        * Visitor       
            为该对象结构中的ConcreteElement的每一个类生命一个Visit操作。该操作的名字标识了发送Visit请求给该访问者的那个类。这使得访问者可以正确被访问元素的具体的类。

        * ConcreteVisitor  
            实现每个由Visitor声明的操作。每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。ConcreteVisitor为该算法提供了上下文并存储它的局部状态。

        * Element
            定义一个Accept操作，它以一个访问者为参数。

        * ConcreteElement  
            实现Accept操作

        * ObjectStructure  
            能枚举它的元素  
            可以提供一个高层的接口以允许该访问者访问它的元素  
            可以是一个复合或者集合。

    * 效果
         1. 访问者模式使得易于增加新的操作
         2. 访问者集中相关的操作而分离无关的操作
         3. 增加新的ConcreteElement类很困难
         4. 通过类层次进行访问
        5. 积累状态
        6. 破换封装

    * 实现
        1. 双分派
            访问者模式允许你不改变类即可有效地增加其上的操作。为达到这一效果使用一种称为*双分派*技术。而C++语言支持*单分派*
        2. 谁负责遍历对象结构
         

        
10. 备忘录模式

    生活中的手机通讯录备忘录，操作系统备份点，数据库备份等都是备忘录模式的应用。备忘录模式是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以把该对象恢复到原先的状态。具体的结构图如下所示：
    
    * 意图  
    在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存状态。这样以后就可将该对象恢复到原先保存的状态。

    * 别名  Token

    * 动机

    * 适用性
        * 必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态。
        * 如果一个用接口来让对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。

    * 结构
        ![]()

    * 参与者
        * Memento   
        备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态。  

        防止元发起以外的其他对象访问备忘录。备忘录实际上有两个接口，管理者（caretaker）只能看到备忘录的窄接口-它只能将备忘录传递给其他对象。相反，原发器
        能看到一个宽接口，允许它访问返回到先前状态的所有数据。理想的情况是只允许生成备忘录的那个原发器访问本备忘录的内部状态。

        * Originator  
        原发器创建一个备忘录，用以记录当前时刻它的内部状态。

        使用备忘录恢复内部状态。

        * Caretaker  
        负责保存好备忘录
        
        不能对备忘录的内容进行操作或检查

    * 协作
        
    * 效果
        1. 保持封装边界
        2. 它简化了原发器
        3. 使用备忘录可能代价很高
        4. 定义窄接口和宽接口
        5. 维护备忘录的潜在代价

    * 实现
        1. 语言支持
        2. 存储增量式改变
        
        
        

11. 解释器模式

    解释器模式是一个比较少用的模式，所以我自己也没有对该模式进行深入研究，在生活中，英汉词典的作用就是实现英文和中文互译，这就是解释器模式的应用。
    解释器模式是给定一种语言，定义它文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释器语言中的句子。具体的结构图如下所示：

    * 意图
        给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该比表示来解释语言中的句子。
    

12. 行为模式的讨论
    1. 封装变化
    2. 对象作为参数
    3. 通信应该被封装还是被发布
    4. 对发送者和接收者解耦
    5. 总结

　