##异步编程：线程概述及使用

###多核心CPU超线程CPU

###操作系统对多核处理器的支持

主要体现在调度和中断上：

1.  对任务的分配进行优化。使同一应用程序的任务尽量在同一个核上执行。

2.  对任务的共享数据优化。由于多核处理器（Chip Multi-Processor，CMP）体系结构共享缓存（目前），可以考虑改变任务在内存中的数据分布，使任务在执行时尽量增加缓存的命中率。

3.  对任务的负载均衡优化。当任务在调度时，出现了负载不均衡，考虑将较忙处理器中与其他任务最不相关的任务迁移，以达到数据的冲突最小。

4.  支持抢先多任务处理的操作系统可以创建多个进程中的多个线程同时执行的效果。它通过以下方式实现这一点：在需要处理器时间的线程之间分割可用处理器时间，并轮流为每个线程分配处理器时间片。当前执行的线程在其时间片结束时被挂起，而另一个线程继续运行。当系统从一个线程切换到另一个线程时，它将保存被抢先的线程的线程上下文，并重新加载线程队列中下一个线程的已保存线程上下文。

###进程和线程

###操作系统中，CPU的两种竞争策略

操作系统中，CPU竞争有很多种策略。Unix系统使用的是时间片算法，而Windows则属于抢占式的。


###线程Thread类详解


1. 常用属性
   

2.  创建线程

    Thread包含使用ThreadStart或ParameterizedThreadStart委托做参数的构造函数，这些委托包装调用Start()时由新线程执行的方法。

    *线程一旦启动，就不必保留对Thread对象的引用。线程会继续执行直到线程所调用委托执行完毕*

    1)         向线程传递数据（见示例）

    我们可以直接使用接收ParameterizedThreadStart参数Thread构造函数创建新线程，再通过Start(object parameter)传入参数并启动线程。由于Start方法接收任何对象，所以这并不是一种类型安全的实现。

    所以我们可以使用一种替代方案：将线程执行的方法和待传递数据封装在帮助器类中，使用无参的Start()启动线程。必要的时候需在帮助器类中使用同步基元对象避免线程共享数据的死锁和资源争用。

    2)         使用回调方法检索数据（见示例）

    Thread构造函数接收的ThreadStart或ParameterizedThreadStart委托参数，这两个委托的声明都是返回void，即线程执行完后不会有数据返回（实际上主线程也不会等待Thread创建的新线程返回，否则创建新线程就无意义了）。那么如何在异步执行完时做出响应呢？使用回调方法。

3.  调度线程

    使用Thread.Priority属性获取或设置任何线程的优先级。优先级：Lowest < BelowNormal< Normal < AboveNormal< Highest

    *低优先级的线程并不是被阻塞直到较高优先级的线程完成，低优先级的线程只是在相同时间间隔被CPU调度的次数相对较少。*

4.   线程状态

    Thread.ThreadState属性提供一个位掩码，用它指示线程的当前状态。

5.   线程状态操作方法

    操作：Start()，Abort()，Suspend()，Resume()， Join()，Interrupt()以及静态方法Sleep()和ResetAbort()

    ![](http://images.cnblogs.com/cnblogs_com/heyuquan/201212/201212161937425842.jpg)

    3)阻塞线程

    调用Sleep()方法使当前线程放弃剩余时间片，立即挂起(阻塞)并且在指定时间内不被调度。

    Sleep(timeout)，会有条件地将调用线程从当前处理器上移除，并且有可能将它从线程调度器的可运行队列中移除。这个条件取决于调用 Sleep 时timeout 参数。

    a)   当 timeout = 0， 即 Sleep(0)，如果线程调度器的可运行队列中有大于或等于当前线程优先级的就绪线程存在，操作系统会将当前线程从处理器上移除，调度其他优先级高的就绪线程运行；如果可运行队列中的没有就绪线程或所有就绪线程的优先级均低于当前线程优先级，那么当前线程会继续执行，就像没有调用 Sleep(0)一样。一个时间片结束时，如果Windows决定再次调度同一个线程（而不是切换到另一个线程），那么Windows不会执行上下文切换。

    b)   当 timeout > 0 时，如：Sleep(1)，可能会引发线程上下文切换（如果发生线程切换）：调用线程会从线程调度器的可运行队列中被移除一段时间，这个时间段约等于 timeout 所指定的时间长度。为什么说约等于呢？是因为睡眠时间单位为毫秒，这与系统的时间精度有关。通常情况下，系统的时间精度为 10 ms，那么指定任意少于 10 ms但大于 0 ms 的睡眠时间，均会向上求值为 10 ms。

    调用Thread.Sleep(Timeout.Infinite)将使线程休眠，直到其他运行线程调用 Interrupt ()中断处于WaitSleepJoin线程状态的线程，或调用Abort()中止线程。

 

    应用实例：轮询休眠

    while (!proceed) Thread.Sleep (x);    // "轮询休眠!"

6.  SpinWait(int iterations)

7.  设置和获取线程的单元状态

8.  设置和检索线程数据（数据槽）

9.  原子操作

    由于编译器，或者CPU的优化，可能导致程序执行的时候并不是真正的按照代码顺序执行。在多线程开发的时候可能会引起错误。

    在debug模式下，编译器不会做任何优化，而当Release后，编译器做了优化，此时就会出现问题。

    1)         Thread.MemoryBarrier()

    按如下方式同步内存存取：执行当前线程的处理器在对指令重新排序时，不能采用先执行 Thread.MemoryBarrier()调用之后的内存存取，再执行 Thread.MemoryBarrier() 调用之前的内存存取的方式。

    2)         Thread.VolatileRead()+Thread.VolatileWrite()   （内部使用MemoryBarrier()内存屏障）

    a)         VolatileRead()           读取字段值。无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。

    b)         VolatileWrite ()         立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。

    3)         关键字Volatile：

    为了简化编程，C#编译器提供了volatile关键字。确保JIT编译器对易失字段都以易失读取或者易失写入的方法执行，不用显示调用Thread的VolatileRead()和VolatileWrite()。


###判断多个线程是否都结束的几种方法


[异步编程：线程概述及使用](http://www.cnblogs.com/heyuquan/archive/2012/12/16/2820775.html)