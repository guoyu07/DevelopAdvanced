#﻿.NET线程同步 
  多线程当中存在线程同步问题，需要使用一些机制去实现同步问题，总结一下.NET平台使用那些机制。

##lock

``` C#
private object  _lockObject=new object(); 

lock(_lockObject)
{
  //execute code
}
```
  一般锁定的关键字使用特定的私有变量就行了,因为被锁住的对象将无法被访问 </br>
  
  [lock 语句](https://msdn.microsoft.com/zh-cn/library/c5kehkcz.aspx)
  
###Monitor

  lock语句的实现本质，都是锁住代码域，之前的代码等价于
  
```C#
Monitor.Enter(_lockObject)
//execute code
Monitor.Exit(_lockObject)
```
  [Monitor 类](https://msdn.microsoft.com/zh-cn/library/system.threading.monitor(v=vs.110).aspx)

##Semaphore

  SemaphoreSlim，CurrentCount属性允许进入SemaphoreSlim的线程数</br>
  `limits the number of threads that can access a resource or pool of resources concurrently`</br>
重要的方法Wait与Release，SemaphoreSlim只是在当前Application有效</br>
`Execute code protected by the semaphore` SemaphoreSlim也是保护code，但是它可以允许多个线程访问区域</br>

  [SemaphoreSlim 类](https://msdn.microsoft.com/zh-cn/library/system.threading.semaphoreslim(v=vs.110).aspx)
  
  Semaphore的作用于SemaphoreSlim的作用是一样的。（区别？）
  
  [Semaphore 类](https://msdn.microsoft.com/en-us/library/system.threading.semaphore(v=vs.110).aspx)
  
  区别：
  * SemaphoreSlim不支持命名,Semaphore可以通过命名跨进程控制，它对系统可见。
  9
  [Semaphore and SemaphoreSlim](https://msdn.microsoft.com/en-us/library/z6zx288a(v=vs.110).aspx)

##Interlocked
  
  实现一些值的原子操作，例如加，减，赋值等，可以实现较为轻量的原子化操作。（Singleton类实现的对lockObject的赋值）
  * Add
  * CompareExchange
  * Decrement(递减)
  * Exchange
  
      可以简单的实现锁的功能。
  * Increment（递增）
  * MemoryBarrier （？）
  * Read(Int64) （32 bit system only）
  
  [Interlocked类](https://msdn.microsoft.com/zh-cn/library/system.threading.interlocked(v=vs.110).aspx)

##Mutex
  
  与Semaphore一直使用命名，属性系统核心对象，可以在进程中共享。有较为复杂的权限控制！user！
  
  * static OpenExisting
  * ReleaseMutex
  * WaitOne (WaitHandle继承)
  
  [Mutex类](https://msdn.microsoft.com/zh-cn/library/system.threading.mutex(v=vs.110).aspx)


##EventWaitHandle

EventWaitHandle类的用途是可以调用其WaitOne方法来阻塞线程的运行，直到得到一个信号（该信号由EventWaitHandle类的Set方法发出），然后释放线程让其不再阻塞继续运行。

EventWaitHandle以及它的派生类AutoResetEvent和ManualResetEvent都是线程无关的。任何线程都可以发信号给EventWaitHandle，以唤醒阻塞在上面的线程。

EventWaitHandle可以跨进程通信。

EventWaitHandle类拥有两种状态，终止状态 （signaled）和 非终止状态（nonsignaled）：
•在终止状态下，被WaitOne阻塞的线程会逐个得到释放，所以当EventWaitHandle始终处于终止状态时，调用其WaitOne方法无法起到阻塞线程的作用，因为线程被其WaitOne方法阻塞后，会立即被释放掉。
•在非终止状态下，被WaitOne阻塞的线程会继续被阻塞，如果一个线程在EventWaitHandle对象处于非终止状态时调用了其WaitOne函数，该线程会立即被阻塞。

需要注意的是终止状态和非终止状态之间，是可以相互转换的。调用EventWaitHandle对象的Set方法既可以将EventWaitHandle对象设置为终止状态，调用EventWaitHandle对象的Reset方法既可以将EventWaitHandle对象设置为非终止状态。


此外，EventWaitHandle类还拥有两种模式，AutoReset 和 ManualReset 模式：
•在AutoReset模式下，当EventWaitHandle对象被置为终止状态时，释放一个被WaitOne阻塞的线程后，EventWaitHandle对象会马上被设置为非终止状态，这个过程就等同于一个被WaitOne阻塞的线程被释放后，自动调用了EventWaitHandle的Reset方法，将EventWaitHandle对象自动从终止状态置回了非终止状态，所以这种模式叫AutoReset模式。所以如果有若干线程被EventWaitHandle对象的WaitOne方法阻塞了，每调用一次EventWaitHandle对象的Set方法将EventWaitHandle对象置为终止状态后，只能释放一个被阻塞的线程，然后EventWaitHandle对象又会被置为非终止状态。如果EventWaitHandle对象的Set方法之后又被调用了一次，剩下那些被阻塞的线程中，又会有一个线程被释放。所以如果有8个被WaitOne方法阻塞的线程，那么需要调用次EventWaitHandle对象的Set方法8次，才能让所有线程都得到释放。需要注意的一点就是MSDN中有提到：如果两次EventWaitHandle对象的Set方法调用非常接近，以至于当第一次调用Set方法后，被阻塞的线程还没有来得及释放，第二次Set调用又开始了，那么这两次Set方法的调用只会让一个被阻塞的线程被释放，也就是说如果两次Set方法的调用过于接近，那么就相当于只调用了一次。原因就是因为由于两次Set调用过于接近，当第一次Set调用后，其释放的线程还没有完全被释放，即EventWaitHandle对象还没有被置回非终止状态，第二次Set调用又开始了，又要求EventWaitHandle对象变成终止状态去释放剩余的阻塞线程，但是问题是现在EventWaitHandle对象本来就处于终止状态，并且第一次Set调用后的那个被释放的线程还没有被完全释放，所以现在不能去释放剩余的阻塞线程。之后待第一次Set调用后的那个被释放线程完全释放后，由于EventWaitHandle对象处于AutoReset模式，所以现在EventWaitHandle对象才会被置回非终止状态，那么就相当于第二次Set调用就白白浪费了一次机会去将EventWaitHandle对象置为终止状态去释放剩余的阻塞线程。
•在ManualReset模式下，当EventWaitHandle对象被置为终止状态时，释放一个被WaitOne阻塞的线程后，其状态不会改变，仍然处于终止状态，所以当ManualReset模式下EventWaitHandle对象处于终止状态时，会连续释放所有被WaitOne方法阻塞的线程，直到手动调用其Reset方法将其置回非终止状态。所以这种模式叫ManualReset模式。

[多线程编程中的EventWaitHandler](http://www.cnblogs.com/OpenCoder/archive/2011/12/29/2305528.html)

* WaitOne
* Set
* Reset
* WaitHandle的3个静态方法SingnalAndWait()/WailAny()/WaitAll()，

* AutoResetEvent
* ManualResetEvent
简化的两个子类


##精彩系列

###C#线程同步（1）- 临界区＆Lock

####临界区（Critical Section）
　　是一段在同一时候只被一个线程进入/执行的代码。为啥要有这个东西？

1.是因为这段代码访问了“临界资源”，而这种资源只能同时被互斥地访问

2.是因为OS的多任务调度

####Lock关键字

####Lock使用的建议

####.NET集合类对lock的支持  SyncRoot

提供SynRoot是为了把这个已经“线程安全”的集合内部所使用的“锁”暴露给你，让你和它内部的操作使用同一把锁，这样才能保证在遍历过程互斥掉其它操作，保证你在遍历的同时没有可以修改。另一个可以替代的方法，是使用集合上提供的静态ReadOnly()方法，来返回一个只读的集合，并对它进行遍历，这个返回的只读集合是线程安全的。

[C#线程同步（1）- 临界区＆Lock](http://www.blogbus.com/xxinside-logs/46441956.html)

###C#线程同步（2）- 临界区＆Monitor

####Monitor中和lock等效的方法

####比lock更“高级”的Monitor

消费者与生产者模式

* 很显然这个容器是一个临界资源（你不会问我为什么是显然吧？），同时只允许一个线程访问。
* 生产者往容器里存放生产好的资源；消费者消费掉容器里的资源。

线程同步遇到两个问题

* 临界区
* 通知
* Wait方法, Pulse方法与PulseAll唤醒  
    注意：以上所有方法都只能在临界区内被调用，换句话说，只有对象锁的获得者能够正确调用它们，否则会引发SynchronizationLockException异常。

[Wait方法](https://msdn.microsoft.com/zh-cn/library/system.threading.monitor.wait(VS.80).aspx)

[C#线程同步（2）- 临界区＆Monitor](http://www.blogbus.com/xxinside-logs/46740731.html)

###C#线程同步（3）- 互斥量 Mutex

####什么是Mutex

“mutex”是术语“互相排斥（mutually exclusive）”的简写形式，也就是互斥量。互斥量跟临界区中提到的Monitor很相似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。互斥量比临界区复杂，因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。.

####MarshalByRefObject 类
允许在支持远程处理的应用程序中跨应用程序域边界访问对象。 

####全局和局部的Mutex

####Mutex的用途
Mutex有个最常见的用途：用于控制一个应用程序只能有一个实例运行。


[C#线程同步（3）- 互斥量 Mutex](http://www.blogbus.com/xxinside-logs/47162540.html)


###C#线程同步（4）- 通知＆EventWaitHandle一家

####线程相关性（Thread Affinity ）
EventWaitHandle和Mutex两者虽然是派生自同一父类，但有着完全不同的线程相关性：

* Mutex与Monitor一样，是“线程相关（Thread Affinity）”的。我们之前已经提到过，只有通过Monitor.Enter()/TryEnter()获得对象锁的线程才能调用Pulse()/Wait()/Exit()；同样的，只有获得Mutex拥有权的线程才能执行ReleaseMutex()方法，否则就会引发异常。这就是所谓的线程相关性。
* 相反，EventWaitHandle以及它的派生类AutoResetEvent和ManualResetEvent都是线程无关的。任何线程都可以发信号给EventWaitHandle，以唤醒阻塞在上面的线程。
* 下一篇要提到的Semaphore也是线程无关的。

####EventWaitHandle的独门秘笈


[C#线程同步（4）- 通知＆EventWaitHandle一家]（http://blog.csdn.net/prettyboy4/article/details/6846723）

###C#线程同步（5）- 信号量 Semaphore

####跟谁更亲，Mutex还是EventWaitHandle？

Semaphore就是一个可以多次进入的“Mutex”。Mutex永远只允许一个线程拥有它，而Semaphore可以允许多个线程请求，因此Semaphore被用于管理一次可以允许多个线程进入并发访问资源的情况。

[C#线程同步（5）- 信号量 Semaphore](http://www.blogbus.com/xxinside-logs/47617134.html)


###C#线程同步（6）- 读写锁 ReaderWriterLock

####ReaderWriterLock锁的好处

> ReaderWriterLock 用于同步对资源的访问。在任一特定时刻，它允许多个线程同时进行读访问，或者允许单个线程进行写访问。在资源不经常发生更改的情况下，ReaderWriterLock 所提供的吞吐量比简单的一次只允许一个线程的锁（如 Monitor）更高。

>  注意长时间持有读线程锁或写线程锁会使其他线程发生饥饿 (starve)。为了得到最好的性能，需要考虑重新构造应用程序以将写访问的持续时间减少到最小。
 一个线程可以持有读线程锁或写线程锁，但是不能同时持有两者。若要获取写线程锁，请使用 UpgradeToWriterLock 和 DowngradeFromWriterLock，而不要通过释放读线程锁的方式获取。
递归锁请求会增加锁上的锁计数。



####ReaderWriterLock的使用方法

* AcquireReaderLock()：获取读线程锁。
* AcquireWriterLock()：获取写线程锁。
* ReleaseReaderLock()：减少锁计数，计数到达零时释放锁。ReleaseReaderLock将减少锁计数。如果线程持有写线程锁，调用 ReleaseReaderLock 与调用 ReleaseWriterLock 具有相同的效果。如果线程没有锁，调用 ReleaseReaderLock 会引发 ApplicationException。
* ReleaseWriterLock()：将减少写线程锁计数。计数变为零时释放写线程锁。如果线程持有读线程锁或没有锁，调用 ReleaseWriterLock 会引发 ApplicationException。
* ReleaseLock()：释放锁，不管线程获取锁的次数如何

[ReaderWriterLock](https://msdn.microsoft.com/zh-cn/library/system.threading.readerwriterlock(VS.80).aspx)

[C#线程同步（6）- 读写锁 ReaderWriterLock](http://www.blogbus.com/xxinside-logs/47780781.html)