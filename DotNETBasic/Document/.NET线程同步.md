#﻿.NET线程同步 
  多线程当中存在线程同步问题，需要使用一些机制去实现同步问题，总结一下.NET平台使用那些机制。

##lock

``` C#
private object  _lockObject=new object(); 

lock(_lockObject)
{
  //execute code
}
```
  一般锁定的关键字使用特定的私有变量就行了,因为被锁住的对象将无法被访问 </br>
  
  [lock 语句](https://msdn.microsoft.com/zh-cn/library/c5kehkcz.aspx)
  
###Monitor

  lock语句的实现本质，都是锁住代码域，之前的代码等价于
  
```C#
Monitor.Enter(_lockObject)
//execute code
Monitor.Exit(_lockObject)
```
  [Monitor 类](https://msdn.microsoft.com/zh-cn/library/system.threading.monitor(v=vs.110).aspx)

##Semaphore

  SemaphoreSlim，CurrentCount属性允许进入SemaphoreSlim的线程数</br>
  `limits the number of threads that can access a resource or pool of resources concurrently`</br>
重要的方法Wait与Release，SemaphoreSlim只是在当前Application有效</br>
`Execute code protected by the semaphore` SemaphoreSlim也是保护code，但是它可以允许多个线程访问区域</br>

  [SemaphoreSlim 类](https://msdn.microsoft.com/zh-cn/library/system.threading.semaphoreslim(v=vs.110).aspx)
  
  Semaphore的作用于SemaphoreSlim的作用是一样的。（区别？）
  
  [Semaphore 类](https://msdn.microsoft.com/en-us/library/system.threading.semaphore(v=vs.110).aspx)
  
  区别：
  * SemaphoreSlim不支持命名,Semaphore可以通过命名跨进程控制，它对系统可见。
  9
  [Semaphore and SemaphoreSlim](https://msdn.microsoft.com/en-us/library/z6zx288a(v=vs.110).aspx)

##Interlocked
  
  实现一些值的原子操作，例如加，减，赋值等，可以实现较为轻量的原子化操作。（Singleton类实现的对lockObject的赋值）
  * Add
  * CompareExchange
  * Decrement(递减)
  * Exchange
  
      可以简单的实现锁的功能。
  * Increment（递增）
  * MemoryBarrier （？）
  * Read(Int64) （32 bit system only）
  
  [Interlocked类](https://msdn.microsoft.com/zh-cn/library/system.threading.interlocked(v=vs.110).aspx)

##Mutex
  
  与Semaphore一直使用命名，属性系统核心对象，可以在进程中共享。有较为复杂的权限控制！user！
  
  * static OpenExisting
  * ReleaseMutex
  * WaitOne (WaitHandle继承)
  
  [Mutex类](https://msdn.microsoft.com/zh-cn/library/system.threading.mutex(v=vs.110).aspx)


