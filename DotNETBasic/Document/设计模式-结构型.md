结构型模式涉及到如何组合类和对象以获得更大的结构。结构型类模式采用继承机制来组合接口或实现。

结构型对象模式不是对接口和实现进行组合，而是描述如何对一些对象进行组合，从而实现新功能的一些方法。因为在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性
，而这种机制用静态类组合是不可能实现的。


1. 适配器模式(Adapter)-类对象结构型模式

    适配器模式意在转换接口，它能够使原本不能再一起工作的两个类一起工作，所以经常用来在类库的复用、代码迁移等方面。例如DataAdapter类就应用了适配器模式。适配器模式包括类适配器模式和对象适配器模式，具体结构如下图所示，左边是类适配器模式，右边是对象适配器模式。
    使用不同的日志系统一般都使用这种模式!一定要有自己的日志接口，否则换日志组件会想死！   

    * 意图
        将一个类的接口转换成客户希望的一个接口。Adapter模式使得原本由于接口不兼容而不能子啊一起工作的那些类可以已经工作。
    * 别名
        包装器 Wrapper
    * 动机
    * 适用性
        * 你想使用一个已经存在的类，而它的接口不符合你的要求。
        * 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作
        * （仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每个都进行子类化已匹配它们的接口。对象适配器可以适配它的父类接口。
    * 结构 
        ![]()

    * 参与者
        * Target
        定义一个Client使用的与特定领域相关的接口
        * Client
        与符合Target接口对象协同。
        * Adaptee
        定义一个已经存在的接口，这个接口需要适配
        * Adapter
        对Adaptee的接口与Target接口进行适配。

    * 协作
        * Client在Adapter实例上调用一些操作。接着适配器调用Adaptee的操作实现这个请求。

    * 效果
        * 类适配器
        * 对象适配器
            允许一个Adapter与多个Adaptee一同工作  
            使得重定义Adaptee行为比较困难 
        * Adapter的匹配程度
        * 可插入的Adapter

    * 实现
        可插入的适配器
        * 使用抽象操作   通过子类调用不同的对象实现父类的功能
        * 使用代理对象 
        * 参数化的适配器  
    * 已知应用
    * 相关模式

            

2. 桥接模式（Bridge）

    桥接模式旨在将抽象化与实现化解耦，使得两者可以独立地变化。意思就是说，桥接模式把原来基类的实现化细节再进一步进行抽象，构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，这样就可以实现系统在多个维度的独立变化，桥接模式的结构图如下所示。
    
    * 意图
        将抽象部分与它的实现部分分离，使他们都可以独立地变化。
    * 别名
        Handle/Body
    * 动机
        当一个抽象可能有多个实现时，通常用继承来协调它们。
    * 适用性
        *　你不需要在抽象和它的实现之间有一个固定的绑定关系。例如这种可能是因为，在程序运行时刻实现部分可以被选择或者切换。
        * 类的抽象以及它的实现应该可以通过生成子类的方法加以扩展
        * 对一个抽象和实现部分进行组合，并分别对它们进行扩充
        * 对抽象实现部分的修改对客户不产生影响，既客户的代码不必重新编译。
        * 你想多个对象间共享实现
    * 结构
        ![]()
    * 参与者
        * Abstraction
        定义一个抽象类的接口
        维护一个只想Implementor类型对象的指针
        * Refined Abstraction
        扩充用Abstaction定义的接口
        * Implementor
        定义实现类的接口，该接口不一定要与Abstaction接口完全一致；事实上这个两个接口可以完全不同。一般来讲，Implementor接口仅提供基本操作，而Abstaction
        则定义基于这些操作的较高层次的操作。
        * ConcreteImplementor
        实现Implementor接口并定义它的具体实现

    * 协作
        * Absraction将Client的请求转发给它的Implementor对象。

    * 效果
        1. 分离接口及其实现部分
        2. 提高可扩充性
        3. 实现细节对客户透明
    * 实现
        1. 仅有一个Implementor 模式退化情况
        2. 创建正确的Implementor对象
        3. 共享Implementor对象
    * 相关模式


3. 装饰者模式

    装饰者模式又称包装（Wrapper）模式，它可以动态地给一个对象添加一些额外的功能，装饰者模式较继承生成子类的方式更加灵活。虽然装饰者模式能够动态地将职责附加到对象上，但它也会造成产生一些细小的对象，增加了系统的复杂度。具体的结构图如下所示。

4. 组合模式

    组合模式又称为部分―整体模式。组合模式将对象组合成树形结构，用来表示整体与部分的关系。组合模式使得客户端将单个对象和组合对象同等对待。如在.NET中WinForm中的控件，TextBox、Label等简单控件继承与Control类，同时GroupBox这样的组合控件也是继承于Control类。组合模式的具体结构图如下所示。

5. 外观模式

    在系统中，客户端经常需要与多个子系统进行交互，这样导致客户端会随着子系统的变化而变化，此时可以使用外观模式把客户端与各个子系统解耦。外观模式指的是为子系统中的一组接口提供一个一致的门面，它提供了一个高层接口，这个接口使子系统更加容易使用。如电信的客户专员，你可以让客户专员来完成冲话费，修改套餐等业务，而不需要自己去与各个子系统进行交互。

6. 享元模式

    在系统中，如何我们需要重复使用某个对象时，此时如果重复地使用new操作符来创建这个对象的话，这对系统资源是一个极大的浪费，既然每次使用的都是同一个对象，为什么不能对其共享呢？这也是享元模式出现的原因。
    享元模式运用共享的技术有效地支持细粒度的对象，使其进行共享。在.NET类库中，String类的实现就使用了享元模式，String类采用字符串驻留池的来使字符串进行共享。更多内容参考博文：http://www.cnblogs.com/artech/archive/2010/11/25/internedstring.html。

7. 代理模式

    在系统开发中，有些对象由于网络或其他的障碍，以至于不能直接对其访问，此时可以通过一个代理对象来实现对目标对象的访问。如.NET中的调用Web服务等操作。

    代理模式指的是给某一个对象提供一个代理，并由代理对象控制对原对象的访问。
