结构型模式涉及到如何组合类和对象以获得更大的结构。结构型类模式采用继承机制来组合接口或实现。

结构型对象模式不是对接口和实现进行组合，而是描述如何对一些对象进行组合，从而实现新功能的一些方法。因为在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性
，而这种机制用静态类组合是不可能实现的。


1. 适配器模式(Adapter)-类对象结构型模式

    适配器模式意在转换接口，它能够使原本不能再一起工作的两个类一起工作，所以经常用来在类库的复用、代码迁移等方面。例如DataAdapter类就应用了适配器模式。适配器模式包括类适配器模式和对象适配器模式，具体结构如下图所示，左边是类适配器模式，右边是对象适配器模式。
    使用不同的日志系统一般都使用这种模式!一定要有自己的日志接口，否则换日志组件会想死！   

    * 意图
        将一个类的接口转换成客户希望的一个接口。Adapter模式使得原本由于接口不兼容而不能子啊一起工作的那些类可以已经工作。
    * 别名
        包装器 Wrapper
    * 动机
    * 适用性
        * 你想使用一个已经存在的类，而它的接口不符合你的要求。
        * 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作
        * （仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每个都进行子类化已匹配它们的接口。对象适配器可以适配它的父类接口。
    * 结构 
        ![]()

    * 参与者
        * Target
        定义一个Client使用的与特定领域相关的接口
        * Client
        与符合Target接口对象协同。
        * Adaptee
        定义一个已经存在的接口，这个接口需要适配
        * Adapter
        对Adaptee的接口与Target接口进行适配。

    * 协作
        * Client在Adapter实例上调用一些操作。接着适配器调用Adaptee的操作实现这个请求。

    * 效果
        * 类适配器
        * 对象适配器
            允许一个Adapter与多个Adaptee一同工作  
            使得重定义Adaptee行为比较困难 
        * Adapter的匹配程度
        * 可插入的Adapter

    * 实现
        可插入的适配器
        * 使用抽象操作   通过子类调用不同的对象实现父类的功能
        * 使用代理对象 
        * 参数化的适配器  
    * 已知应用
    * 相关模式

            

2. 桥接模式（Bridge）

    桥接模式旨在将抽象化与实现化解耦，使得两者可以独立地变化。意思就是说，桥接模式把原来基类的实现化细节再进一步进行抽象，构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，这样就可以实现系统在多个维度的独立变化，桥接模式的结构图如下所示。
    
    * 意图
        将抽象部分与它的实现部分分离，使他们都可以独立地变化。
    * 别名
        Handle/Body
    * 动机
        当一个抽象可能有多个实现时，通常用继承来协调它们。
    * 适用性
        *　你不需要在抽象和它的实现之间有一个固定的绑定关系。例如这种可能是因为，在程序运行时刻实现部分可以被选择或者切换。
        * 类的抽象以及它的实现应该可以通过生成子类的方法加以扩展
        * 对一个抽象和实现部分进行组合，并分别对它们进行扩充
        * 对抽象实现部分的修改对客户不产生影响，既客户的代码不必重新编译。
        * 你想多个对象间共享实现
    * 结构
        ![]()
    * 参与者
        * Abstraction
        定义一个抽象类的接口
        维护一个只想Implementor类型对象的指针
        * Refined Abstraction
        扩充用Abstaction定义的接口
        * Implementor
        定义实现类的接口，该接口不一定要与Abstaction接口完全一致；事实上这个两个接口可以完全不同。一般来讲，Implementor接口仅提供基本操作，而Abstaction
        则定义基于这些操作的较高层次的操作。
        * ConcreteImplementor
        实现Implementor接口并定义它的具体实现

    * 协作
        * Absraction将Client的请求转发给它的Implementor对象。

    * 效果
        1. 分离接口及其实现部分
        2. 提高可扩充性
        3. 实现细节对客户透明
    * 实现
        1. 仅有一个Implementor 模式退化情况
        2. 创建正确的Implementor对象
        3. 共享Implementor对象
    * 相关模式


3. 装饰者模式(Decorator)

    装饰者模式又称包装（Wrapper）模式，它可以动态地给一个对象添加一些额外的功能，装饰者模式较继承生成子类的方式更加灵活。虽然装饰者模式能够动态地将职责附加到对象上，但它也会造成产生一些细小的对象，增加了系统的复杂度。具体的结构图如下所示。
    * 意图 
        动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相对于生成子类更为灵活

    * 别名
        包装器Wrapper
    * 动机
    * 适用性
        * 在不影响其他对象的情况下，已动态、透明的方式给单个对象添加职责
        * 处理那些可以撤销的职责
        * 当不能采用生成子类的方法进行扩充时。
    * 结构
        ![]()
    * 参与者
        * Component
        定义一个对象接口，可以给这些对象动态地添加职责。   
        * ConcreteComponent
        定义一个对象，可以给这个对象添加一些职责
        * Decorator
        维持一个执行Component对象的指针，并定义一个与Component接口一致的接口
        * ConcreateDecorator
        向组件添加职责
    * 协作
        * Decorator将请求发给它的Component对象，并有可能在转发请求前后执行一些附加的动作

    * 效果
        1. 比静态类灵活
        2. 避免在层次结构高层的类有太多的特征
        3. Decorator与它的Component不一样
        4. 有许多小对象
        
    * 实现
        1. 接口一致性
        2. 省略抽象的Decorator类
        3. 保持Component类的简单性
        4. 改变对象外壳和改变对象外壳
        
    * 已知应用

    * 想关模式
        
    

4. 组合模式(Composite)

    组合模式又称为部分―整体模式。组合模式将对象组合成树形结构，用来表示整体与部分的关系。组合模式使得客户端将单个对象和组合对象同等对待。如在.NET中WinForm中的控件，TextBox、Label等简单控件继承与Control类，同时GroupBox这样的组合控件也是继承于Control类。组合模式的具体结构图如下所示。

    * 意图
        将对象组合成树形结构已表示"部分-整体"的层次结构。Compsite使得用户将单个对象和组合对象的使用具有一致性。

    * 动机
    * 适用性
        * 你想表示对象的部分-整体层次结构
        * 你希望用户忽略组合对象和单个对象的不同，用户将统一的使用组合结构中的所有对象，
    * 结构
        ![]()
    * 参与者
        * Component   
        为组合中的对象声明接口
        在适当的情况下，实现所有类共有接口的缺省行为
        声明一个接口用于访问和管理Component的子组件
        (可选)在递归结构中定义一个接口，用于访问一个父部件，并在何时的情况下实现它，
        * Leaf
        在组合中表示叶节点对象，叶节点没有子节点
        在组合中定义图元对象的行为
        * Composite
        定义有子部件的那些部件的行为
        存储子部件
        在Component接口中实现与子部件有关的操作
        * Client
        通过Component接口操作组合部件的对象
      
    * 协作
        * 用户使用Component类接口和组合结构中的对象进行交互。如果接受者是一个叶节点，则直接处理请求。如果接受者是Composite,
        它通常将请求发送给它的子部件，在转发请求之前/或之后可能执行一些辅助操作

    * 效果
        * 定义一个了包含基本对象和组合对象的类层次结构
        * 简化客户代码
        * 使得更容易增加新类型的组件
        * 使你的设计更加一般化

    * 实现
        * 显示的父部件应用
        * 共享组件   只有一个父部件是，很难共享组件
        * 最大化Component接口
        * 声明管理子部件的操作
        * Component是否应该实现一个Component列表
        * 子部件的排序
        * 使用一个高速缓冲存贮改善性能
        * 应该由谁删除Component
        * 存贮组建最好用哪一种数据结构
    * 已知应用
    * 相关模式
        
       

5. 外观模式(Facade)

    在系统中，客户端经常需要与多个子系统进行交互，这样导致客户端会随着子系统的变化而变化，此时可以使用外观模式把客户端与各个子系统解耦。外观模式指的是为子系统中的一组接口提供一个一致的门面，它提供了一个高层接口，这个接口使子系统更加容易使用。如电信的客户专员，你可以让客户专员来完成冲话费，修改套餐等业务，而不需要自己去与各个子系统进行交互。

    * 意图
        为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一个子系统更加容易使用。

    * 动机
        将一个系统分成若干子系统有利于降低系统的复杂性。一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小。
        达到该目标的途径之一就是引入一个外观对象，它为子系统中较一般的设施提供了一个单一而简单的界面。
        
    * 适用性
        * 当你要为一个复杂子系统提供一个简单的接口时。
        * 客户程序和抽象类的实现之间存在很大的依赖性
        * 当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。
    * 结构
        ![]()
    * 参与者
        * Facade
        知道哪些子系统处理请求
        将客户的请求处理给适当的子系统对象
        * Subsystem classes
        处理子系统的功能
        处理由Facade对象指派的任务
        没有facade的任何相关信息;既没有指向facede的指针
    * 协作
        * 客户程序通过发送请求给Facsde的方法与子系统通讯，Facede将这些信息转发给适当的子系统对象。
        * 使用Facade的客户程序不需要直接访问子系统对象

    * 效果
        1. 它对客户屏蔽子系统组件
        2. 它实现了子系统和客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的。
        3. 如果应用需要，它并不限制它们使用子系统类。

    * 实现
        1. 降低客户-子系统之间的耦合度
        2.  公共子系统类和私有子系统类
    * 相关模式
         
    
6. 享元模式(Flyweight)

    在系统中，如何我们需要重复使用某个对象时，此时如果重复地使用new操作符来创建这个对象的话，这对系统资源是一个极大的浪费，既然每次使用的都是同一个对象，为什么不能对其共享呢？这也是享元模式出现的原因。
    享元模式运用共享的技术有效地支持细粒度的对象，使其进行共享。在.NET类库中，String类的实现就使用了享元模式，String类采用字符串驻留池的来使字符串进行共享。更多内容参考博文：http://www.cnblogs.com/artech/archive/2010/11/25/internedstring.html。

    * 意图
        运用共享技术有效地支持大量细粒度的对象

    * 动机
        
    * 适用性
        * 一个应用程序使用了大量的对象。(Image缓存就使用了类似的技术)
        * 完全由于使用大量的对象，造成很大的存储开销
        * 对象的大多数都可变为外部状态
        * 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很大组对象
        * 应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将放回真值。
    
    * 结构
        ![]()
    * 参与者
        * Flyweight  
        描述一个接口，通关这个接口flyweight可以接受作用于外部状态。
        * ConcreteFlyweight  
        实现Flyweight接口，并为内部状态增加存储空间。ConcreteFlyweight对象必须是可共享的，它所存储的状态必须是内部的；    
        它必须独立于ConcreteFlyweight对象的场景  
        * UnsharedConcreteFlyweight
        * FlyweightFactory  
        创建并管理flyweight对象     
        确保合理的共享flyweight。当客户请求一个flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个
        * Client    
         维持一个对flyweight引用    
        计算或存储一个(多个)flyweight的外部状态

    * 协作
        * flyweight执行时所需的状态必定是内部状态或外部状态。内部状态存储于ConcreteFlyweight对象之中；而
        外部对象则有Client对象存储或计算。当用户调用flyweight对象的操作时，将该状态传递给它。
        * 用户不能直接对ConcreteFlyweight类进行实例化，而只能从FlyweightFactory对象得到CincreteFlyweight对象

    * 效果
        节约存储空间的因素
        * 因为共享，实例总是减少的数目
        * 对象内部状态的平均数目
        * 外部状态是计算还是存储的

    * 实现
        1. 删除外部状态
        2. 管理共享对象
        
    * 相关模式

7. 代理模式(Proxy)

    在系统开发中，有些对象由于网络或其他的障碍，以至于不能直接对其访问，此时可以通过一个代理对象来实现对目标对象的访问。如.NET中的调用Web服务等操作。

    代理模式指的是给某一个对象提供一个代理，并由代理对象控制对原对象的访问。

    * 意图
        为其他对象提供一种代理以控制对这个对象的访问

    * 别名
        Surrogate

    * 动机
        图像代理

    * 适用性
        在需要用比较通用和复杂的对象指针代理简单的指针的时候，使用Proxy模式。使用代理的常见情况:
        1. 远程代理(Remote Proxy)
        2. 虚代理(Virtual Proxy) 根据需要创建开销很大的对象
        3. 保护代理(Projection Proxy)控制对原始对象的访问
        4. 智能指针(Smart Reference)取代简单的指针，它子啊访问对象时进行了一些附加操作
        
    * 结构
        ![]()
    * 参与者
        * Proxy  
            保存一个引用使得代理可以访问实体。若RealSuject和Subject的接口相同，Proxy会引用Subject  
            提供一个与Subject的接口系统的接口，这个代理就可以用来替换实体。  
            控制对实体的存取，并可能创建和删除它  
            其他功能依赖于代理类型  
                * Remote Proxy负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求。
                * Virtual Proxy 可以缓存实体的附加信息，以便延迟对它的访问。
                * Protection Proxy 检查调用者是否具有实现一个请求所必需的访问权限。

        * Subject
            定义一个RealSubject和Proxy的公用接口，这样就在任何使用RealSuject的地方可以使用Proxy。

        * RealSubject
            定义Proxy所代表的实体

    * 效果
        Proxy模式在访问对象时引入了一定程度的间接性

        Proxy模式还可以对用户隐藏另一种称之为copy-on-write的方法，该优化与根据需要创建对象有关。

    * 实现
        Proxy并不需要总是需要知道实体的类型

