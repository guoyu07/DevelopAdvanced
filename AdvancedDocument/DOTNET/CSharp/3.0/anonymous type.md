[C# 3.0 新特性 学习（二）：匿名类型、扩展方法 ](http://www.cnblogs.com/joey0210/archive/2012/10/25/2739017.html)

顾名思义 匿名类型就是没有名字的类型。在C#3.0中允许我们在程序中声明一个临时的类型来存储数据

```cs
var obj = new { Name = "Joey", Age = 25 };//创建对象
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 } };//创建数组
```

感觉在测试和学习用的会比较多。


在MSDN 中匿名类型的定义是这样的：

1. 匿名类型提供了一种方便的方法，可用来将一组只读属性封装到单个对象中，而无需首先显式定义一个类型。 
2. 类型名由编译器生成，并且不能在源代码级使用。每个属性的类型由编译器推断。
3. 可通过使用 new 运算符和对象初始值创建匿名类型。

上面三句话是所谓的”说到点子上了”.让人一看就明白匿名类型。但是在这里，我还得提一提，匿名类型和var 隐式类型化的声明关键字的关系；
很多新手在看到var 声明时，就觉得这是一个匿名对象，匿名类型的对象是必须用var 来声明，但是用var 声明的对象不一定都是匿名对象，
例如 var n=5; 你就不能说n 是一个匿名对象，n只是一个隐式类型化的局部变量；而 var  s=new{ S1="abc",S2="def"}; s 则是一个
 类型为匿名类型的对象。也就是说 匿名对象是 用var 声明的一个 在内存中临时的类型的对象。它的类型不能像隐式类型那样根据右边的实例
画表达式来推断类型，它是一个实实在在的匿名类型，而var i=5; 这种隐式类型的声明，编译时，i其实还是 int32 类型，隐式类型只是一种语法糖。

 
那匿名类型一般都在什么情况下使用呢？

1. 匿名类型通常用在查询表达式的 select 子句中，以便返回源序列中每个对象的属性子集(Linq 中使用的比较多）


匿名类型包含一个或多个公共只读属性。 包含其他种类的类成员（如方法或事件）为无效。 用来初始化属性的表达式不能为 null、匿名函数或指针类型。
最常见的方案是用其他类型的属性初始化匿名类型。在下面的示例中，假定名为 Product 的类存在。 类 Product 包括 Color 和 Price 属性，
以及您不感兴趣的其他属性。 变量                  products 是 Product 对象的集合。 匿名类型声明以 new 关键字开始。 声明初始化了一个只
使用 Product 的两个属性的新类型。 这将导致在查询中返回较少数量的数据。

如果您没有在匿名类型中指定成员名称，编译器会为匿名类型成员指定与用于初始化这些成员的属性相同的名称。 必须为使用表达式初始化的属性提供名称，
如下面的示例所示。 在下            面示例中，匿名类型的属性名称都为 Color 和 Price。          
 
```cs
var productQuery = from prod in products
                  select new { prod.Color, prod.Price };

foreach (var v in productQuery)
{
    Console.WriteLine("Color={0}, Price={1}", v.Color, v.Price);
}
```

上面的查询中使用一个匿名对象保存了查询的结果。 new { prod.Color,prod.Price} 匿名类型，会使用 查询结果prod 对象的Color属性
和Price属性作为新的匿名对象的属性。
 
可通过将隐式键入的本地变量与隐式键入的数组相结合创建匿名键入的元素的数组，如下面的示例所示。
 var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};

上面的代码是将两个匿名对象存入一个匿名的数组中。需要注意的是，在上面代码中，匿名数组存储的匿名对象的初始化器里的属性类型和属性名称
和属性的数量必须一致。也就是说

new { name = "apple", diam = 4 }＝new { name = "grape", diam = 1 } 成立的条件是： 属性名字和属性存储的值的类型以及属性个
数必须全部相同，vs  编译器才会认为这两个匿名类型是同一个类型。这样的两个匿名类型才能够存入 anonArray 这样的一个匿名数组中。
因为匿名数组也只能存储同一种类型的匿名对象。
